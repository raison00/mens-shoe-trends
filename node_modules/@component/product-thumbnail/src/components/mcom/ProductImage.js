// #MODULE - ProductImage
// > Author: Michael Moir
// > Migrate: Balasubramanian Karthikesan
// > Create Date: Dec 29, 2016
//
// ##DESCRIPTION:
// AMD module to handle macys.com product images.  This has utility functions to create Scene7 URLs
// and functions to make a carousel experience out of "alt images".
import _ from 'underscore';
import $ from 'jquery';
import ProductImage from '../ProductImage';
import imageSrc from '../../helpers/imageSrc';

const DEFAULT_WIDTH = 224;
const DEFAULT_HEIGHT = 270;
const imageHost = 'https://slimages.macysassets.com/is/image/MCY';
// ###Method - addExtensionIfNeeded
// Every image reference to Scene7 must be a .tif extension.  This function just ensures that it is.
//
// > parameters
// >
// + str - the file path, or file name of the image.
//
// > returns
// >
// + string - the same file or name, but now certainly ending in .tif.
function addExtensionIfNeeded(str) {
  let val = str;
  if (!val.endsWith('.tif')) {
    val += '.tif';
  }
  return $.trim(val);
}

// ###Method - buildSimpleUrlBase
// This is an internal method in this module that does the building of the filepath for a Scene7
// image.  This way, the exposed methods can all reuse this method and it centralizes the logic.
//
// > parameters
// >
// + baseImgUrl (optional) - Pass in undefined if you want the default value, or override the default
// + srcImg - The "filepath" portion of the image.  This is the typical filepath found in data
// + imgWidth (optional) - Override the default width by passing in your own, otherwise the default is used.
//
// > returns
// >
// + string - the image URL to be used as an image tag SRC value
function buildSimpleUrlBase(baseImgUrl, srcImg, imgWidth) {
  return imageSrc({
    urlTemplate: baseImgUrl,
    primaryImage: {
      filePath: srcImg,
      width: imgWidth,
    },
  });
}

// ###Method - buildSpriteUrlBase
// This is an internal method in this module that does the building of the filepath for a Scene7
// image that is a "collage" of all the images in srcArray.  This way, the exposed methods can all reuse
// this method and it centralizes the logic.
//
// > parameters
// >
// + srcArray - an array of filepath strings representing each image
// + baseImgUrl (optional) - Pass in undefined if you want the default value, or override the default
// + imgWidth (optional) - Override the default width by passing in your own, otherwise the default is used.
// + imgHeight (optional) - Override the default height by passing in your own, otherwise the default is used.
// + imgQuality (optional) - Override the default quality by passing in your own, otherwise the default is used.
//
// > returns
// >
// + {DESC}.
function buildSpriteUrlBase(srcArray, baseImgUrl, imgWidth, imgHeight, imgQuality) {
  // STEP: Validate: srcArray is required...return NULL if not supplied
  if (!srcArray || baseImgUrl === '') {
    return null;
  }

  const baseUrl = baseImgUrl || imageHost;
  const filePathArray = srcArray;
  const wid = imgWidth || DEFAULT_WIDTH;
  const hei = imgHeight || DEFAULT_HEIGHT;
  const qual = imgQuality || '$filtermed$';
  const imgCount = filePathArray.length;
  const scene7filters = `?&$m=MCY/products/&${qual}&layer=0&cropN=0,0,${imgCount},1&size=${wid * imgCount},${hei}`;
  let spriteUrl = `${baseUrl}/${scene7filters}`;

  for (let i = 0; i < imgCount; i += 1) {
    spriteUrl += `&src=is{$m$${addExtensionIfNeeded(filePathArray[i])}}&anchor=0,0`;
    spriteUrl += `&layer=${i + 1}&size=${wid},${hei}`;
    spriteUrl += `&posN=${(1 / imgCount) * (i + 1)},0`;
  }
  // NOTE: This is final width of the image, and must be below the scene 7 threshold
  const win = 2500;
  const imgW = wid * imgCount;
  const finalWidth = win < imgW ? win : imgW;
  spriteUrl += `&wid=${finalWidth}`;

  return spriteUrl;
}

// ###Method - getImageUrlFromData
// This expects the standard Product Model (http://confluence5/display/CAPPSCATALOG/Product+Domain+Model)
// This will take in the data and then return a properly formatted Scene7 based href for the image
//
// > parameters
// >
// + data - the standard Macys.com Inc Domain Product Model
//
// > returns
// >
// + string - the image URL to be used as an image tag SRC value
function getImageUrlFromData(data) {
  const img = data.imagery;
  if (img) {
    const primeImg = img.primaryImage;
    let width;
    if (primeImg) {
      if (!_.isEmpty(primeImg.width)) {
        ({ width } = primeImg);
      }

      return buildSimpleUrlBase(img.urlTemplate, primeImg.filePath, width);
    }
  }

  // If the above did not succeed pass undefined values and let the function return failover image
  return buildSimpleUrlBase(undefined, undefined, undefined);
}

// ###Method - attachAdditionalImages
// This method will attach the additional images to the given image for the effect of rotating multiple images for a product.
//
// As this is a complex method, please note some things.  It will rotate via "swipe" when there is more than two images.
// It will fade between images when there are only two.  And it will do nothing when there is only one.
//
// Considering the "primary Image" as defined by the image that is set as the "src" attr for the <img> tag, the primary image needs be in the
// first index of the array, but only in the condition when there is more than two.
//
// > parameters
// >
// + jQueryImage - The image tag as selected via jQuery.  This is the image that will get the treatment.
//
// > returns
// >
// + Nothing.
function attachAdditionalImages(jqueryImage) {
  let count = 1;
  // NOTE: Now we are in running code...

  // NOTE: we expect that the array of alt image paths is in a data attr named "data-src" (<img data-src="path1,path2"/>)
  // STEP: Get the image alt filepaths comma delimited string
  const imageArrayString = $(jqueryImage).data('src');
  // STEP: If that filepath comma delimited string was found, then make it into an array of filepath strings.
  const imageArray = imageArrayString && imageArrayString.length > 0 ? imageArrayString.split(',') : [];

  // STEP: Extract the image filepath from the image src attr in order to compare if it is already in alt image array
  const imgSrc = this.getImagePathFromImageUrl($(jqueryImage).attr('src'));

  // STEP: check if the primary imagePath is in the first index of the imageArray
  // NOTE: Since we cycle through all the images, ensure that the current shown image (primary) is part of the array of images
  if ($.inArray(imgSrc, imageArray) !== 0) {
    imageArray.unshift(imgSrc);
  }

  // NOTE: Get image count now
  const imageCount = imageArray.length;

  // NOTE: Start the images at 1 because 0 already shows primary
  count = 1;

  // STEP: Define some inner functions right here...jshint likes them at the top of the scope.
  function fadeInOut() {
    let hoverTimeout;
    $(jqueryImage)
      .hover(
        () => {
          hoverTimeout = setTimeout(() => {
            let hoverInterval;
            const wid = Math.round($(jqueryImage)
              .parent()
              .width());
            const hei = $(jqueryImage).height();
            const hoverImageSrc = $(jqueryImage).attr('data-src');
            const hoverImageArray = hoverImageSrc && hoverImageSrc.length > 0 ? hoverImageSrc.split(/[ ,]+/) : [];

            // STEP: Again, we expect primary image to be in [0], so we want to use [1]
            const imgUrl = buildSimpleUrlBase(undefined, hoverImageArray[1], wid);
            if ($(`#thumb${hoverInterval}`).length === 0) {
              $(jqueryImage).wrap($(`<div id="thumb${hoverInterval}">`)
                .css({
                  margin: '0',
                  padding: '0',
                  width: `${wid}px`,
                  height: `${hei}px`,
                  overflow: 'hidden',
                  'background-image': `url(${imgUrl})`,
                  'background-repeat': 'no-repeat',
                  display: 'inline-block',
                  'vertical-align': 'top',
                })
                .hover(
                  () => {},
                  () => {
                    $(jqueryImage)
                      .fadeIn()
                      .unwrap(`div#thumb${hoverInterval}`);
                    clearInterval(hoverInterval);
                  },
                ));

              hoverInterval = setInterval(() => {
                if ($(jqueryImage).is(':visible')) {
                  $(jqueryImage).fadeOut();
                } else {
                  $(jqueryImage).fadeIn();
                }
              }, 1250);
            }
          }, 500);
        },
        () => {
          clearTimeout(hoverTimeout);
        },
      )
      .data('carousel-on', true);
  }

  function rotatingImages() {
    let hoverInterval;
    let hoverTimeout;
    $(jqueryImage)
      .hover(
        () => {
          hoverTimeout = setTimeout(() => {
            const wid = $(jqueryImage).width();
            const hei = $(jqueryImage).height();

            // this change is made to incorporate selected color swatch product image, also jquery's data("src") will output the default value stored
            // which in turn outputs default selected color product image
            const hoverImageSrc = $(jqueryImage).attr('data-src');
            const hoverImageArray = hoverImageSrc && hoverImageSrc.length > 0 ? hoverImageSrc.split(',') : [];
            const imgUrl = buildSpriteUrlBase(hoverImageArray, undefined, wid, hei);

            $(jqueryImage).wrap($('<div>')
              .css({
                margin: '0',
                padding: '0',
                width: `${wid}px`,
                height: `${hei}px`,
                overflow: 'hidden',
                'background-image': `url(${imgUrl})`,
                'background-repeat': 'no-repeat',
                'background-position': `-${count * wid}px`,
                'background-size': `${hoverImageArray.length * wid}px, ${hei}px`,
              })
              .hover(
                () => {},
                () => {
                  if (imageCount > 0) {
                    count = 1;
                    $($(jqueryImage).parent('div')).animate(
                      {
                        'background-position': `-${count * wid}px`,
                      },
                      200,
                      'linear',
                    );
                    $(jqueryImage).fadeIn();
                    clearInterval(hoverInterval);
                    $(jqueryImage).unwrap('div');
                  }
                },
              ));
            $(jqueryImage).fadeOut();
            hoverInterval = setInterval(() => {
              count += 1;
              if (count < hoverImageArray.length) {
                $($(jqueryImage).parent('div')).animate(
                  {
                    'background-position': `-${count * wid}px`,
                  },
                  200,
                  'linear',
                );
              } else {
                count = 0;
                $($(jqueryImage).parent('div')).animate(
                  {
                    'background-position': '0px',
                  },
                  200,
                  'linear',
                );
              }
            }, 1100);
          }, 500);
        },
        () => {
          clearTimeout(hoverTimeout);
        },
      )
      .data('carousel-on', true);
  }

  // STEP: This is what to do when there are more than 2 images...
  if (imageCount > 2) {
    rotatingImages();
  }

  // STEP: This is what to do when there is exactly 2 images...because of code above, we expect primary image to ALWAYS be index 0
  if (imageCount === 2) {
    fadeInOut();
  }
}

// NOTE: This is the public interface to this module
const mcomProductImage = {
  attachAdditionalImagesByCollection(jqueryImageArray) {
    const that = this;
    $(jqueryImageArray).each((idx, obj) => {
      that.attachAdditionalImages(obj);
    });
  },
  attachAdditionalImages(jqueryImage) {
    attachAdditionalImages.call(this, jqueryImage);
  },
  buildSimpleUrl(baseImgUrl, srcImg, imgWidth) {
    return buildSimpleUrlBase(baseImgUrl, srcImg, imgWidth);
  },
  buildSpriteUrl(srcList, baseImgUrl, imgWidth, imgHeight, imgQuality) {
    return buildSpriteUrlBase(srcList, baseImgUrl, imgWidth, imgHeight, imgQuality);
  },
  getImageSpriteSrc(data) {
    return buildSpriteUrlBase(_.pluck(data.imagery.additionalImageSource, 'filePath'), data.imagery.urlTemplate);
  },
  getImageSrc(data) {
    return getImageUrlFromData(data);
  },
};
export default _.extend(ProductImage, mcomProductImage);
