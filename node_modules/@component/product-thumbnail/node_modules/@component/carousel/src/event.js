/**
 * Created by Daniel Sarmiento on 12/27/17.
 */

const EVTREG = Symbol('eventRegistry');

/**
 * For an object to be able to emit events and handle listeners it
 * can extend or mixin this class.
 * i.e. class SomeClass extends EventSource.
 *      or in the constructor of SomeClass: EventSource.mixin(this);
 *
 * @author Daniel Sarmiento
 */
export default class EventSource {
  /**
     * Copy all the functions from EventSource to passed target object.
     * @param target
     * @returns {*}
     */
  static mixin(target) {
    const t = target;
    const traceName = 'EventSource.mixin:';
    if (typeof t !== 'object') {
      throw new Error(`${traceName} target must be an object.`);
    }
    const mixins = ['on', 'off', 'emit', 'wrap', 'unwrap', 'getListeners', EVTREG];
    const es = new EventSource();
    for (let i = 0; i < mixins.length; i += 1) {
      t[mixins[i]] = es[mixins[i]];
    }
    return t;
  }

  /**
     * Initialize this EventSource with Map => this[Symbol('eventRegistry')] = new Map()
     */
  constructor() {
    this[EVTREG] = new Map();
  }

  /**
     * this[EVTREG] => Map[Event, Map[listener, context]]
     * on a particular event SAMPLE_EVENT
     * get the listener Map stored against SAMPLE_EVENT or create a new one.
     * If this listener is not registered against SAMPLE_EVENT, then store it in Map with context.
     * @param evt
     * @param listener
     * @param context
     * @returns {EventSource}
     */
  on(evt, listener, context) {
    if (typeof evt !== 'string') {
      throw new TypeError('EventSource: evt argument must be a string.');
    }
    if (!listener || typeof listener !== 'function') {
      throw new TypeError('EventSource: listener argument must be a function.');
    }
    const listeners = this[EVTREG].get(evt) || new Map();
    if (!listeners.has(listener)) {
      listeners.set(listener, context);
      this[EVTREG].set(evt, listeners);
    }
    return this;
  }

  /**
     * this[EVTREG] => Map[Event, Map[listener, context]]
     *
     * @param args = off(evt, listener)
     * evt & listener
     * If you pass evt => it will find listenerMap against that evt.
     * If you pass listener also with evt, it will delete only that listener from listenerMap, otherwise it will clear all the map.
     *
     * listener only
     * If you pass listener function only, it will try to find the listener function against all the evt, and delete it
     *
     * nothing passed:
     * it will clear evt map.
     * @returns {EventSource}
     */

  off(...args) {
    let [evt, listener] = args;
    if (typeof evt === 'function') {
      listener = evt;
      evt = null;
    }
    if (evt) {
      const listenerMap = this[EVTREG].get(evt);
      if (listenerMap) {
        if (listener) {
          listenerMap.delete(listener);
        } else {
          listenerMap.clear();
        }
      }
    } else if (listener) {
      this[EVTREG].forEach(listenerMap => listenerMap.delete(listener));
    } else {
      this[EVTREG].clear();
    }
    return this;
  }

  /**
     *
     * @param evt = event name
     * get all the listeners against this evt from this[EVTREG] map.
     * call all the listeners with assigned context, and passed args.
     * @param args
     */
  emit(evt, ...args) {
    if (!evt || evt === '*') {
      return;
    }
    const entries = this.getListeners(evt, '*');
    for (let i = 0; i < entries.length; i += 1) {
      const { event, listener, context } = entries[i];
      const params = event === '*' ? [evt, ...args] : args;
      listener.apply(context, params);
    }
  }

  /**
     * Bind the eventSource with emit function
     * @param eventSource
     */
  wrap(eventSource) {
    if (!eventSource) {
      return;
    }
    eventSource.on('*', this.emit, this);
  }

  /**
     * unbind the eventSource from emit function
     * @param eventSource
     */
  unwrap(eventSource) {
    if (!eventSource) {
      return;
    }
    eventSource.off(this.emit);
  }

  /**
     *
     * @param events = Array of event names
     * Find out all the listeners against this event and return it.
     * @returns {Array}
     */
  getListeners(...events) {
    if (events && events.length > 0) {
      const collector = [];
      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];
        const evtReg = this[EVTREG].get(event);
        if (evtReg) {
          evtReg.forEach((context, listener) => collector.push({
            event,
            listener,
            context,
          }));
        }
      }
      return collector;
    }
    const allEvts = [];
    this[EVTREG].forEach((_, evt) => allEvts.push(evt));
    return allEvts.length > 0 ? this.getListeners(...allEvts) : [];
  }
}
