/**
 * Name: Davis Yi, Daniel Sarmiento
 * Date: 12/18/2017
 * Description:
 *  Carousel is a parent class of carousel components
 *  that visualize list of element inline
 *  and let user scroll them through vertically or horizontally.
 */
import EventSource from '../event';
import {
  isElement, asArray, isDefined, isTouchEnabled, isMousedown,
  getTransformInfo, translate, globals, setA11State, calculateBoxDimension,
} from '../util';

require(`../scss/carousel/${process.env.ENTRY_POINT}/carousel.scss`);

const { getNavigator } = globals;

export const ArrowIconSize = {
  FULL: 'full',
  HUGE: 'huge',
  LARGE: 'large',
  MEDIUM: 'medium',
  SMALL: 'small',
  TINY: 'tiny',
};

/**
 * Define the scrolling type of the carouse.
 * For PAGE the carousel will scroll by the quantity of items defined in
 * the page.childPerPage field.
 * For ITEM the carousel only will scroll by one item.
 */
export const ScrollType = {
  PAGE: 'page',
  ITEM: 'item',
};

/**
 * Event emitted when the next button is clicked or when a left slide [end <-- start]
 * occurred in a touch screen enabled device and this is a horizontal carousel.
 * If is a vertical carousel the slide up slide will trigger this event.
 * @type {string}
 */
export const NEXT_EVENT = 'next_event';
/**
 * As in NEXT_EVENT but in reverse direction.
 * @type {string}
 */
export const PREV_EVENT = 'prev_event';
/**
 * Event emitted when the carouse think is the best time to load the next page of data.
 * @type {string}
 */
export const LAST_PAGE_EVENT = 'last_page_event';
/**
 * Event emitted after the carousel has been rendered.
 * @type {string}
 */
export const READY_EVENT = 'ready_event';

export const PAGE_SHOWN_EVENT = 'page_shown';

export const SWIPE_EVENT = 'swipe_event';

export const HORIZONTAL = 'horizontal';
export const VERTICAL = 'vertical';

const { userAgent } = getNavigator();

const defaultOpts = {
  type: HORIZONTAL,
  childrenView: [],
  arrowIconSize: ArrowIconSize.HUGE,
  scrollType: ScrollType.PAGE,
  swipeSensibility: 20,
  // set up speed velocity. Edge need more velocity
  swipeVelocity: userAgent.indexOf('Edge') !== -1 ? 3 : 1.5,
  maxItemsCount: 0,
  event: true,
  ssr: false,
  hideButtons: 'medium',
  swatch: true,
  autoplay: false,
  autoplayInterval: 5000,
  infinity: false,
  overlayButtons: false,
};

const firstPageDefault = 1;

const BUTTON = {
  PREV: 0,
  NEXT: 1,
};

let swipeInAction = false;

export default class Carousel extends EventSource {
  /**
     *
     * @param {*} opts
     *  1. el - holder DOM element or id. (required)
     *  2. childrenView - list of DOM element that should be populated as child view
     *  3. scrollType - define the scrolling type of the carousel (ScrollType.PAGE, ScrollType.ITEM)
     *  4. event - automatically add event listener of click, and touch (default: true)
     *  5. arrowIconSize - size of arrows icon
     *  (ArrowIconSize.FULL, ArrowIconSize.HUGE, ArrowIconSize.MEDIUM, ArrowIconSize.SMALL,
     *  ArrowIconSize.TINY)
     *  6. ssr - indicate if the view was server side rendered so the Carousel just must attach its
     *  behavior to the existing html element.
     */
  constructor(opts = {}) {
    super();

    if (typeof opts.el !== 'string' && !isElement(opts.el)) {
      throw new TypeError("Carousel: The 'el' option must be a string or an HTML Element.");
    }


    // set options with default. if option is given, then override them.
    this.opts = Object.assign({}, defaultOpts, opts);

    this.instanceType = this.opts.type;
    // true indicate there's no more items to show (no more items will be added in the future)
    this.endOfDataReached = false;

    /**
         * Scroll Related variables
         */
    this.childSize = {
      childHeight: 0,
      childWidth: 0,
    };

    // Page is keep track of pagination of the carousel
    this.page = {
      current: firstPageDefault,
      max: firstPageDefault,
      childPerPage: 1,
    };

    // Scroll Related Props
    this.scrollerPos = {
      start: {
        x: 0,
        y: 0,
      },
      transform: 0,
      newPositionValue: {
        x: 0,
        y: 0,
      },
    };

    // Bind class to the event listener function to remove event properly
    this.resizeEventListener = this.resizeEventListener.bind(this);
    this.nextButtonEventListener = this.nextButtonEventListener.bind(this);
    this.prevButtonEventListener = this.prevButtonEventListener.bind(this);


    this.pointerUpEventListener = this.pointerUpEventListener.bind(this);
    this.pointerMoveEventListener = this.pointerMoveEventListener.bind(this);
    this.pointerDownEventListener = this.pointerDownEventListener.bind(this);
    this.pointerLeaveEventListener = this.pointerLeaveEventListener.bind(this);

    this.mousedown = false;
    this.touchEnabled = false;
    this.isPageShownEventPending = false;
    this.childrenView = [];
  }


  /**
     * getter function that returns page information of the carousel
     * page includes
     * 1. current page
     * 2. maximum page
     * 3. child per page information
     */
  get getPage() {
    return this.page;
  }

  /**
     * getter function that returns number of element in the carousel
     */
  get length() {
    return this.childrenView.length;
  }

  /**
     *
     */
  render() {
    // if Carousel is purely client side render, then create carousel view
    if (!this.opts.ssr) {
      this.carouselView = document.createElement('div');
      this.carouselView.innerHTML = this.opts.template({
        size: this.opts.arrowIconSize,
        swatch: this.opts.swatch,
        screenSize: this.opts.hideButtons,
      });
    } else {
      // otherwise fetch holder element and gather server side rendered childeren
      this.carouselView = document.getElementById(this.opts.el.slice(1));
    }


    /**
         * Get shadow DOMs from the carousel template
         * 1. childrenViewWrapper - unordered list live inside of the carouselView
         * 2. button - up/down or left/right buttons [up/down] or [left/right]
         * 3. wrapper - top level carousel wrapper
         */

    this.childrenView = this.childrenView.concat(this.opts.childrenView);
    this.carouselWrapper = this.carouselView.querySelector('.carouselWrapper');
    this.buttons = this.carouselView.querySelectorAll('.m-carousel-button');
    this.carousel = this.carouselView.querySelector('.carousel');
    this.scroller = this.carouselView.querySelector('.scroller');

    if (this.opts.autoplay && this.childrenView.length > 1) {
      const autoPlayInterval = setInterval(() => {
        if (!this.opts.autoplay) {
          clearInterval(autoPlayInterval);
        } else {
          this.next();
        }
      }, this.opts.autoplayInterval);
    }

    // if this is server side rendering, retrieve pre appended children
    // and add new child at the end of the list
    if (this.opts.ssr) {
      // Create Node List out of Server Side rendered HTML Collection
      const preAppendChildren = asArray(this.scroller.getElementsByTagName('li'));
      // Concat List of Server side rendered children and list of given element
      this.childrenView = preAppendChildren.concat(this.opts.childrenView);
    }

    // append new list of children at the end of the list
    this.opts.childrenView.forEach(childView => this.carousel.appendChild(childView));

    this.el = this.opts.el;
    if (typeof this.el === 'string') {
      this.el = document.querySelector(this.el);
      if (!this.el) {
        throw Error(`Carousel: Element not founded for selector ${this.opts.el}.`);
      }
    }

    // if this is client side render, append carousel into the holder
    if (!this.opts.ssr) {
      if (this.el.firstChild) {
        this.el.removeChild(this.el.firstChild);
      }

      this.el.appendChild(this.carouselView);
    }

    return this;
  }

  // eslint-disable-next-line class-methods-use-this
  doSizing() {
    // implemented by child classes
  }

  onWindowLoad() {
    this.doSizing();

    // Excute button enabler
    this.buttonEnabler();
    // attach buttons event listener
    this.addEventListener();

    this.emit(READY_EVENT, this.pageInfo());
    // if there's only one page shown
    if (this.isLastPage()) {
      this.emit(LAST_PAGE_EVENT, this.pageInfo());
    }
    this.emit(PAGE_SHOWN_EVENT, this.pageInfo());
    // Execute tab management for visible carousel items
    this.doA11y();
  }

  handleSizing() {
    // Get First child height to calculate offset to the next
    this.onWindowLoad();
  }

  /**
     * addchild add dom element at the end of the view
     * @param { Element } childView
     */
  addChild(childView) {
    // if new element is not a dom element, then false
    if (!isElement(childView)) {
      return false;
    }

    // Add new childview in the children view list
    this.childrenView.push(childView);

    // append the end of carousel
    this.carousel.appendChild(childView);

    // recalculate the size of carousel
    this.doSizing();

    // Enable next button if page overflow
    this.buttonEnabler();

    return true;
  }

  /**
     * addChildren add multiple dom element at the end of the view
     * @param { Element } children - list of dom element
     */
  addChildren(children) {
    if (!isDefined(children) || children.length === 0) {
      return false;
    }
    // if children is a NodeList converts it to array
    const childArray = asArray(children);
    // if some element is not a dom element, then nothing will be added
    const areAllElements = !childArray.some(child => !isElement(child));

    if (areAllElements) {
      const firstItemsAdded = this.childrenView.length === 0;
      // Add new childview in the children view list
      this.childrenView = this.childrenView.concat(childArray);
      // Optimization to reduce dom manipulation
      const buffer = document.createDocumentFragment();
      childArray.forEach(c => buffer.appendChild(c));
      this.carousel.appendChild(buffer);

      // recalculate the size of carousel
      this.doSizing();
      if (firstItemsAdded) {
        this.page.current += 1;
        this.moveToNthPage();
      } else if (this.isPageShownEventPending) {
        this.isPageShownEventPending = false;
        this.emit(PAGE_SHOWN_EVENT, this.pageInfo());
      }
      // Enable next button if page overflow
      this.buttonEnabler();
    }

    return areAllElements;
  }

  /**
     * removeChild is a function that removes specific child from the array
     * @param { Number } index - index of the childView
     */
  removeChild(index) {
    /**
         *  if index is not a number or length of node list is smaller
         *  then return false to indicate it has not done
         */
    if (typeof index !== 'number' || (this.childrenView.length <= index) || index < 0) {
      return false;
    }

    // get temporary reference to the childview
    // const childView = this.childrenView[index];
    const childView = this.childrenView.splice(index, 1)[0];

    // remove child view from nodeList
    // this.childrenView = _.filter(this.childrenView, (view, key) => key !== index);

    // remove child view from DOM
    this.carousel.removeChild(childView);

    // resize the carousel after remove child
    this.doSizing();

    // if current page is more than new max, then go to prev
    // otherwise, check if button must be enabled or not
    if (this.page.current > this.page.max) {
      this.prev();
    } else {
      this.buttonEnabler();
    }

    return true;
  }

  childAt(pos) {
    if (pos < 0 || pos >= this.childrenView.length) {
      throw new Error(`The index ${pos} is out of the bounds of the children collection.`);
    }
    return this.childrenView[pos];
  }

  /**
     * prev iterate through children views to figure out which child view is the first child view
     * that is not visible on the current carousel page to scroll one page previously
     */
  prev() {
    if (!this.isFirstPage()) {
      this.page.current -= 1;
      this.lastItemShown();
      this.emit(PREV_EVENT, this.pageInfo());
      this.moveToNthPage();
      return true;
    } else if (this.opts.infinity) {
      this.moveToLastPage();
      return true;
    }
    return false;
  }

  /**
     * next iterate through children views to figure out which child view is the first child view
     * that is not visible on the current carousel page to scroll one page next
     */
  next() {
    if (!this.isLastPage()) {
      this.page.current += 1;
      this.lastItemShown();
      this.emit(NEXT_EVENT, this.pageInfo());
      this.moveToNthPage();
      return true;
    } else if (this.opts.infinity) {
      this.moveToFirstPage();
      return true;
    }
    return false;
  }

  /**
     * Just maintain last item shown in carousel, so we can re-calculate this.page.current again in doSizing().
     */
  lastItemShown() {
    const lastItemShown = this.page.current * this.page.childPerPage;
    if (lastItemShown > this.childrenView.length) {
      this.page.lastItemShown = this.childrenView.length;
    } else {
      this.page.lastItemShown = lastItemShown;
    }
  }

  /**
     *  doA11y finds the visible carousel items and sets their tabindex for focus management
     */
  doA11y() {
    // scroll to next element or page
    let visibleIndex;
    let range;
    let calcChildren;
    // Since We're doing this in the base view we need a way to determine
    // if a extended childview was either horizontal or vertical
    const isVertical = this.instanceType === VERTICAL;
    // Since we can't use childeperpage to calculate our number of children per page
    const childDim = calculateBoxDimension(this.childAt(0));
    if (isVertical) {
      // If we have initialized a vertical carousel our number of children is simply calculated based on height
      calcChildren = Math.round(this.carouselWrapper.offsetHeight / childDim.height);
    } else {
      // Otherwise we know that our horizontal carousel is calculated based on width
      calcChildren = Math.round(this.carouselWrapper.offsetWidth / childDim.width);
    }

    // page by page carousels require a different visible index.
    if (this.opts.scrollType === ScrollType.PAGE) {
      range = this.page.current * this.page.childPerPage;
      visibleIndex = range - this.page.childPerPage;
    } else {
      // we know that page.current when 1 is the start of visible index
      visibleIndex = (this.page.current === 1) ? 0 : this.page.current;
      // Conditional logic for calculating slideshow. We know that a slideshow only shows one item at a time,but we need to
      // also account for horizontal scroll using element by element scrolling
      range = (calcChildren === 1) ? visibleIndex : (visibleIndex + calcChildren);
    }
    // we now have to figure out what our visible range is.
    this.childrenView.forEach((element) => {
      // This is important we want to reset all of our nodes to hidden so that we restrict our tabbable area
      // this is for keyboards
      setA11State(element, false, true);
    });

    // we have previously established all the information needed to establish our visible carousel items
    // but we now have to make them focusable for assistive technology

    if (range !== visibleIndex) {
      for (let i = visibleIndex; i < range; i += 1) {
        if (i < this.childrenView.length) {
          const child = this.childAt(i);
          // making currently visible carousel items accessible
          // this is for keyboard
          setA11State(child, true, true);
        }
      }
    } else {
      const child = (visibleIndex === 0) ? this.childAt(visibleIndex) : this.childAt(visibleIndex - 1);
      // making currently visible carousel items accessible
      // this is for keyboard
      setA11State(child, true, true);
    }
  }


  /**
     * [EVENT LOGIC]
     * add event listener removes all events from DOM
     */
  addEventListener() {
    const self = this;

    // window resize event listener
    window.addEventListener('resize', self.resizeEventListener);

    if (self.opts.event) {
      // prev/next button event listener
      if (self.buttons.length) {
        self.buttons[0].addEventListener('click', self.prevButtonEventListener);
        self.buttons[1].addEventListener('click', self.nextButtonEventListener);
      }

      // arrow key event listener
      self.carousel.addEventListener('keydown', self.keyDownEventListener);

      if (userAgent.indexOf('Edge') !== -1) {
        // Mouse, Pen drag screen sroll movement event listener for Edge
        self.scroller.addEventListener('pointerdown', self.pointerDownEventListener);
        self.scroller.addEventListener('pointermove', self.pointerMoveEventListener);
        self.scroller.addEventListener('pointerup', self.pointerUpEventListener);
        self.scroller.addEventListener('pointerleave', self.pointerLeaveEventListener);
      } else {
        self.scroller.addEventListener('touchstart', self.pointerDownEventListener);
        self.scroller.addEventListener('touchmove', self.pointerMoveEventListener);
        self.scroller.addEventListener('touchend', self.pointerUpEventListener);

        // Mouse drag screen sroll movement event listener
        self.scroller.addEventListener('mousedown', self.pointerDownEventListener);
        self.scroller.addEventListener('mousemove', self.pointerMoveEventListener);
        self.scroller.addEventListener('mouseup', self.pointerUpEventListener);
        self.scroller.addEventListener('mouseleave', self.pointerLeaveEventListener);
      }
    }
  }


  /**
     * [EVENT LOGIC]
     * Remove event listener removes all events from DOM in order to prevent
     * memory leak
     */
  removeEventListener() {
    const self = this;

    // window resize event listener
    window.removeEventListener('resize', self.resizeEventListener);

    if (self.opts.event) {
      // prev/next button event listener
      if (self.buttons.length) {
        self.buttons[0].removeEventListener('click', self.prevButtonEventListener);
        self.buttons[1].removeEventListener('click', self.nextButtonEventListener);
      }

      // arrow key event listener
      self.carousel.removeEventListener('keydown', self.keyDownEventListener);

      // if the browser is edge
      if (userAgent.indexOf('Edge') !== -1) {
        self.scroller.removeEventListener('pointerdown', self.pointerDownEventListener);
        self.scroller.removeEventListener('pointermove', self.pointerMoveEventListener);
        self.scroller.removeEventListener('pointerup', self.pointerUpEventListener);
        self.scroller.removeEventListener('pointerleave', self.pointerLeaveEventListener);
      } else {
        self.scroller.removeEventListener('touchstart', self.pointerDownEventListener);
        self.scroller.removeEventListener('touchmove', self.pointerMoveEventListener);
        self.scroller.removeEventListener('touchend', self.pointerUpEventListener);
        // Mouse drag screen sroll movement event listener
        self.scroller.removeEventListener('mousedown', self.pointerDownEventListener);
        self.scroller.removeEventListener('mousemove', self.pointerMoveEventListener);
        self.scroller.removeEventListener('mouseup', self.pointerUpEventListener);
        self.scroller.removeEventListener('mouseleave', self.pointerLeaveEventListener);
      }
    }
  }


  /**
     * [EVENT LOGIC]
     * event listener callback function for prev button
     * @param { Event } event - Javascipt event
     */
  prevButtonEventListener() {
    this.opts.autoplay = false;
    this.prev();
  }


  /**
     * [EVENT LOGIC]
     * event listener callback function for next button
     * @param { Event } event - Javascipt event
     */
  nextButtonEventListener() {
    this.opts.autoplay = false;
    this.next();
  }


  triggerNextEvent() {
    if (!this.buttons.length) return;

    this.buttons[1].click();
  }

  /**
     * [EVENT LOGIC]
     * event listener callback function for window resize event
     */
  resizeEventListener() {
    clearTimeout(this.resizedFinished);
    this.resizedFinished = setTimeout(() => {
      this.doSizing();
      this.moveToNthPage();
      this.doA11y();
      this.buttonEnabler();
    }, 0);
  }

  /**
     * [EVENT LOGIC]
     * mouseDownEventListener excutes when user start to mouse on the screen enabled device
     * @param { EVENT } event
     */
  pointerDownEventListener(event) {
    this.opts.autoplay = false;
    // check if user left click or single touch on scroller
    this.touchEnabled = isTouchEnabled(event);
    this.mousedown = isMousedown(event);

    // if user press left click then record current mouse position
    // We only need to prevent default on mouse down
    if (this.mousedown) {
      event.preventDefault();
      this.saveScrollerPosition(event.clientX, event.clientY);
    } else if (this.touchEnabled) {
      // store timestamp of interaction start
      this.saveScrollerPosition(event.touches[0].pageX, event.touches[0].pageY);
    }
  }

  /**
     * [EVENT LOGIC]
     * mouseMoveEventListener excutes when user start to make a move
     * @param { EVENT } event
     */
  pointerMoveEventListener(event) {
    this.opts.autoplay = false;
    // if user pressed mouse left button then move scroller
    if (this.mousedown) {
      this.changeScrollerPosition(event.clientX, event.clientY);
    } else if (this.touchEnabled) {
      this.changeScrollerPosition(event.touches[0].pageX, event.touches[0].pageY);
    }
    swipeInAction = this.touchEnabled || this.mousedown;
  }

  /**
     * [EVENT LOGIC]
     * mouseUpEventListener excutes when user release mouse button
     * @param { EVENT } event
     */
  pointerUpEventListener() {
    this.opts.autoplay = false;
    this.mousedown = false;
    this.touchEnabled = false;
    if (swipeInAction) {
      const data = {
        scrollerPos: this.scrollerPos,
        childSize: this.childSize,
        carouselWrapper: this.carouselWrapper,
        childLength: this.childrenView.length,
        childPerPage: this.page.childPerPage,
      };
      this.page.current = this.calculateCurrentPageForSwipe(data);
      this.emit(SWIPE_EVENT, this.pageInfo());
      // move to the nearest page
      this.moveToNthPage();
    }
    swipeInAction = false;
  }

  /**
     * [EVENT LOGIC]
     * pointerLeaveEventListener triggers mouse up to cancel mouse move when mouse goes
     * out of the div
     * @param { EVENT } event
     */
  pointerLeaveEventListener(event) {
    this.opts.autoplay = false;
    if (this.mousedown) {
      // Create mouse up event and manually trigger
      const newEvent = document.createEvent('HTMLEvents');
      const eventName = (!(userAgent.indexOf('Edge') > -1))
        ? 'mouseup'
        : 'pointerup';
      newEvent.initEvent(eventName, false, true);
      event.target.dispatchEvent(newEvent);
    }
  }

  moveToFirstPage() {
    this.page.current = 1;
    this.moveToNthPage();
  }

  moveToLastPage() {
    this.page.current = this.page.max;
    this.moveToNthPage();
  }

  /**
     *
     */
  moveToNthPage() {
    const { current, childPerPage } = this.page;
    // Calculate offset to the top of the child view that must be visible next
    const offset = this.calculateOffsetForPage(this.page, this.childSize);

    // Apply offset
    this.scroller.style.transform = translate(this.scroller, offset.x, offset.y);

    if (!this.endOfDataReached && this.isLastPage()) {
      this.emit(LAST_PAGE_EVENT, this.pageInfo());
    }

    // Enable next / prev button according to the current view
    this.buttonEnabler();
    this.doA11y();
    const isFullPageShown = current * childPerPage <= this.childrenView.length;
    if (isFullPageShown || (this.endOfDataReached && this.isLastPage())) {
      this.emit(PAGE_SHOWN_EVENT, this.pageInfo());
    } else {
      this.isPageShownEventPending = true;
    }
  }

  /**
     * [EVENT LOGIC]
     * event listener callback function for onScroll event
     */
  buttonEnabler() {
    /**
     * Next and Prev button toggler.
     * 1. if the scroll is at the beginning, then disable previous button and enable next
     * 2. if the scroll is at the middle, enable both side
     * 3. if the scroll is at the end, disable next and enable prev button
     *
     * ps: if infinity scroller is true, then it should not apply disabled property to any buttons
     */

    if (this.opts.infinity && this.childrenView.length > this.page.childPerPage) {
      this.enableButton(BUTTON.PREV);
      this.enableButton(BUTTON.NEXT);
    } else {
      if (this.spaceForAllChildren()) {
        this.disableButton(BUTTON.PREV);
        this.disableButton(BUTTON.NEXT);
        return;
      }

      if (this.isFirstPage()) {
        // Disable prev button
        this.disableButton(BUTTON.PREV);

        // if there is only one element, do not enable the next button
        if (this.childrenView.length > this.page.childPerPage) {
          // enable next button
          this.enableButton(BUTTON.NEXT);
        } else {
          // disable next button
          this.disableButton(BUTTON.NEXT);
        }
      } else if (this.isLastPage()) {
        // Disable next button
        this.disableButton(BUTTON.NEXT);
        // enable prev button
        this.enableButton(BUTTON.PREV);
      } else {
        // enable prev button
        this.enableButton(BUTTON.PREV);
        // enable next button
        this.enableButton(BUTTON.NEXT);
      }
    }
  }

  enableButton(buttonIndex) {
    if (!this.buttons.length) return;

    this.buttons[buttonIndex].classList.add('enabled');
    this.buttons[buttonIndex].removeAttribute('disabled');
  }

  disableButton(buttonIndex) {
    if (!this.buttons.length) return;

    // disable next button
    this.buttons[buttonIndex].classList.remove('enabled');
    this.buttons[buttonIndex].setAttribute('disabled', true);
  }

  /* set current mousepointer or finger position for mouse or touch event.
     * @param { Number } posX
     * @param { Number } posY
     */
  saveScrollerPosition(posX, posY) {
    this.scrollerPos.start.x = posX;
    this.scrollerPos.start.y = posY;
    this.scrollerPos.transform = getTransformInfo(this.scroller);
  }

  /**
     * Helper function that sets new scroll postion of carousel
     * @param { Number } posX
     * @param { Number } posY
     * @param { String } orientaion
     */
  changeScrollerPosition(posX, posY) {
    const newPos = this.calculateNewScrollerPosition({
      posX,
      posY,
    });
    this.scrollerPos.newPositionValue = newPos;
    const { x, y } = newPos;
    translate(this.scroller, x, y);
  }

  isFirstPage() {
    return this.page.current === firstPageDefault;
  }

  isLastPage() {
    return this.page.current === this.page.max;
  }

  setEndOfData(isEnd) {
    this.endOfDataReached = isEnd;
    if (this.isPageShownEventPending) {
      this.isPageShownEventPending = false;
      this.emit(PAGE_SHOWN_EVENT, this.pageInfo());
    }
  }

  dispose() {
    this.removeEventListener();
    this.off();
  }

  pageInfo() {
    return {
      current: this.page.current,
      childPerPage: this.page.childPerPage,
      max: this.page.max,
      lastItemShown: this.page.lastItemShown,
      totalItems: this.childrenView.length,
    };
  }
}
