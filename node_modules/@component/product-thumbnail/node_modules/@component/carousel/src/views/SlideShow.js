/**
 * Name: Davis Yi, Daniel Sarmiento
 * Date: 12/18/2017
 * Description:
 *  Horizontal Carousel is a Carousel component that visualize list of element inline
 *  and let user scroll them through horizontally.
 */

import Carousel, {
  ScrollType,
  HORIZONTAL,
} from './Carousel';
import { calculateBoxDimension, handleSpaceEnter } from '../util';
import template from '../templates/partials/carousel/SlideShow.hbs';

require(`../scss/carousel/${process.env.ENTRY_POINT}/slideshow.scss`);

const DEFAULT_AUTO_SLIDE_INTERVAL = 7000; // 7 seconds
const MINIMUM_REMAINING_TIME = 500; // 0.5 seconds

const AUTO_SLIDE_SHOW_DEFAULT = {
  timeIds: null,
  currentTimeId: null,
  startTime: 0,
  remainingTime: 0,
  state: 0, // idle: 0, running: 1, pause: 2, resume: 3
};

// Global Variables that keeps track of each slide show properties
const autoSlideShow = {};
let slideShowUid = 0;

export default class SlideShow extends Carousel {
  constructor(opts) {
    // Call parent class constructor
    super(Object.assign({}, opts, { template, scrollType: ScrollType.ITEM, type: HORIZONTAL }));

    // initialize pagination info
    this.pagination = { el: null, dots: [], current: 0 };

    this.dotsClickEvent = this.dotsClickEvent.bind(this);
    this.next = this.next.bind(this);
    this.runAutoSlideShow = this.runAutoSlideShow.bind(this);
    this.pauseAutoSlideShow = this.pauseAutoSlideShow.bind(this);
    this.resumeAutoSlideShow = this.resumeAutoSlideShow.bind(this);
  }

  render() {
    super.render();

    const hasChildren = this.childrenView.length > 0;
    if (hasChildren) {
      if (this.el.id.length === 0) {
        this.el.id = `csg-slideshow-node-${slideShowUid}`;
        slideShowUid += 0;
      }

      // Set Auto Slide Show Default
      autoSlideShow[this.el.id] = Object.assign({}, AUTO_SLIDE_SHOW_DEFAULT, { timeIds: [] });

      // Get Pagination DOM Element
      this.pagination.el = this.el.querySelector('.slide-show-pagination');


      // Populate pagination
      for (let pageCount = 0; pageCount < this.childrenView.length; pageCount += 1) {
        const paginationDot = document.createElement('div');
        const paginationWrapper = document.createElement('li');
        paginationWrapper.classList.add('paginationDot-wrapper');
        paginationWrapper.setAttribute('role', 'button');
        paginationWrapper.setAttribute('tabindex', '0');
        paginationWrapper.setAttribute('aria-selected', 'false');
        paginationDot.classList.add('slide-show-dots');
        paginationWrapper.dataset.page = pageCount + 1;
        paginationWrapper.setAttribute('aria-label', `Go to slide ${paginationWrapper.dataset.page}`);

        if (this.page.current - 1 === pageCount) {
          paginationDot.classList.add('active');
          paginationWrapper.setAttribute('aria-selected', 'true');
          this.pagination.current = pageCount;
        }
        paginationWrapper.appendChild(paginationDot);
        this.pagination.el.appendChild(paginationWrapper);
        this.pagination.dots.push(paginationWrapper);

        // Avoid to render the dots when it has only 1 slide
        if (this.childrenView.length === 1) {
          paginationWrapper.style.visibility = 'hidden';
        }
      }

      // Get First child height to calculate offset to the next
      this.handleSizing();
      this.runAutoSlideShow();
    }
    return this;
  }

  onWindowLoad() {
    // Get first child width to calculate offset to the next, only if parent element is visible
    this.childSize.childWidth = this.carouselWrapper.clientWidth;
    super.onWindowLoad();
    this.slideShowChildViewSizing();
  }

  /**
   * slideShowChildViewSizing resize all children element to size of carousel width
   */
  slideShowChildViewSizing() {
    // Calculate new children width
    const width = this.carouselWrapper.clientWidth;

    // Assign new value of children width into class variable
    this.childSize.childWidth = width;

    // change child width
    for (let index = 0; index < this.childrenView.length; index += 1) {
      this.childrenView[index].style.width = `${width}px`;
    }
  }

  /**
     *  doSizing is resize height of the carousel
     */
  doSizing() {
    if (this.childrenView.length === 0) {
      return;
    }

    // get integer value of carousel Wrapper height
    // const carouselWrapperWidth = this.el.offsetWidth - (this.buttons[0].offsetWidth * 2);
    const carouselWrapperWidth = this.el.offsetWidth;

    // set carousel wrapper width again
    this.carouselWrapper.style.width = `${carouselWrapperWidth}px`;

    // Resize all children to size of carousel wrapper width
    this.slideShowChildViewSizing();

    // Resize carousel Wrapper height and scroller's width
    this.scroller.style.width = `${this.childrenView.length * carouselWrapperWidth}px`;

    // else next/prev button move one element by one element
    this.page.max = this.childrenView.length;
    this.lastItemShown();

    // if IE 11 manually set height of button to make in center
    if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0) {
      this.buttons[0].style.height = `${this.carouselWrapper.clientHeight}px`;
      this.buttons[1].style.height = `${this.carouselWrapper.clientHeight}px`;
    }
  }

  calculateOffsetForPage() {
    const { current, childPerPage } = this.page;
    return { x: -this.childSize.childWidth * (current - 1) * childPerPage, y: 0 };
  }

  // this.scrollerPos, posX, posY, this.opts.swipeVelocity
  calculateNewScrollerPosition({ posX }) {
    const offsetX = this.scrollerPos.start.x - posX;
    const { translateX } = this.scrollerPos.transform;
    const newPositionValue = Object.assign({}, this.scrollerPos.newPositionValue);
    // calculate the new offet, scroller position - mouse offet
    newPositionValue.x = Number(translateX) - (offsetX * this.opts.swipeVelocity);
    return newPositionValue;
  }

  calculateCurrentPageForSwipe({
    scrollerPos, childSize, carouselWrapper, childLength, childPerPage,
  }) {
    const { newPositionValue } = scrollerPos;
    const { x } = newPositionValue;
    const { childWidth } = childSize;
    const { clientWidth } = carouselWrapper;

    let page;
    // if theres no previous page to show set page to the first page index
    if (x > 0) {
      page = 1;
    } else if (Math.abs(x) > ((childLength * childWidth) - clientWidth)) {
      // else if bottom of the last child is too low, bring it back
      page = this.page.max;
    } else {
      // else track to the nearest page
      // calculate nearest page since the drop and shoe it
      page = Math.round(Math.abs(x / (childWidth * childPerPage))) + 1;
    }
    return page;
  }

  spaceForAllChildren() {
    const carouselWrapperWidth = this.el.offsetWidth - (this.buttons[0].offsetWidth * 2);
    const { width, marginRight } = calculateBoxDimension(this.childrenView[0]);
    return carouselWrapperWidth >= ((width * this.childrenView.length) - marginRight);
  }

  moveToNthPage() {
    // remove active state from the last dot
    this.pagination.dots[this.pagination.current].firstElementChild.classList.remove('active');
    this.pagination.dots[this.pagination.current].setAttribute('aria-selected', 'false');

    // set the new current
    this.pagination.current = this.page.current - 1;
    super.moveToNthPage();
    this.pagination.dots[this.pagination.current].setAttribute('aria-selected', 'true');

    // add active state on new dot
    this.pagination.dots[this.pagination.current].firstElementChild.classList.add('active');
  }

  dotsClickEvent(event) {
    // get page data value from the dot DOM
    const { page } = event.target.dataset;

    // set new current page
    this.page.current = Number(page);

    // move to the page
    this.moveToNthPage();
  }

  static dotsKeyPressEvent(event) {
    handleSpaceEnter(event, event.target);
  }
  /**
     * [EVENT LOGIC]
     * add event listener removes all events from DOM
     */
  addEventListener() {
    super.addEventListener();
    for (let index = 0; index < this.pagination.dots.length; index += 1) {
      this.pagination.dots[index].addEventListener('click', this.dotsClickEvent);
      this.pagination.dots[index].addEventListener('keypress', SlideShow.dotsKeyPressEvent);
    }

    // Mouse hover over and leave event
    this.carouselWrapper.addEventListener('mouseenter', this.pauseAutoSlideShow);
    this.carouselWrapper.addEventListener('mouseleave', this.resumeAutoSlideShow);
  }

  /**
     * [EVENT LOGIC]
     * Remove event listener removes all events from DOM in order to prevent
     * memory leak
     */
  removeEventListener() {
    super.removeEventListener();
    for (let index = 0; index < this.pagination.dots.length; index += 1) {
      this.pagination.dots[index].removeEventListener('click', this.dotsClickEvent);
      this.pagination.dots[index].removeEventListener('keypress', SlideShow.dotsKeyPressEvent);
    }

    // Mouse hover over and leave event
    this.carouselWrapper.removeEventListener('mouseenter', this.pauseAutoSlideShow);
    this.carouselWrapper.removeEventListener('mouseleave', this.resumeAutoSlideShow);
  }


  /**
   * Name: runAutoSlideShow
   * Description: this function starts auto slide show every 7 seconds
   */
  runAutoSlideShow() {
    if ((this.page.max > 1) && (autoSlideShow[this.el.id].state === 0 || autoSlideShow[this.el.id].state === 3)) {
      // Run next function if it is resume state before set new interval
      if (autoSlideShow[this.el.id].state === 3) {
        this.next();
        this.clearAllIntervals();
      }

      // Record current start time and run next function by interval
      autoSlideShow[this.el.id].startTime = new Date();
      autoSlideShow[this.el.id].currentTimeId = window.setInterval(this.next, DEFAULT_AUTO_SLIDE_INTERVAL);
      autoSlideShow[this.el.id].timeIds.push(autoSlideShow[this.el.id].currentTimeId);
      autoSlideShow[this.el.id].state = 1;
    }
  }

  /**
   * [EVENT LOGIC]
   * Name: pauseAutoSlideShow
   * Description: this function clears out existing autoslide show from
   *              browser and save the remaining time
   * @param { Event } event - DOM element event
   */
  pauseAutoSlideShow() {
    // calculate remaining time and clear the invertal to prevent auto slideshow
    const remainingTime = DEFAULT_AUTO_SLIDE_INTERVAL - (new Date() - autoSlideShow[this.el.id].startTime);
    autoSlideShow[this.el.id].remainingTime = (remainingTime > 0) ? remainingTime : MINIMUM_REMAINING_TIME;
    this.clearAllIntervals();
    autoSlideShow[this.el.id].state = 2;
  }

  /**
   * clearAllIntervals iterate through all timeIds that created by runSlideShow and clear them.
   */
  clearAllIntervals() {
    for (let index = 0; index < autoSlideShow[this.el.id].timeIds.length; index += 1) {
      window.clearInterval(autoSlideShow[this.el.id].timeIds[index]);
    }

    autoSlideShow[this.el.id].timeIds = [];
  }

  /**
   * [EVENT LOGIC]
   * Name: pauseAutoSlideShow
   * Description: this function clears out existing autoslide show from
   *              browser and save the remaining time
   * @param { Event } event - DOM element event
   */
  stopAutoSlideShow() {
    // calculate remaining time and clear the invertal to prevent auto slideshow
    autoSlideShow[this.el.id].remainingTime = DEFAULT_AUTO_SLIDE_INTERVAL;
    this.clearAllIntervals();

    autoSlideShow[this.el.id].state = 0;
  }

  /**
   * [EVENT LOGIC]
   * Name: resumeAutoSlideShow
   * Description: this function use remaining time calculated previously
   *              to set the timeout until slide changes and run autoslideshow
   * @param { Event } event - DOM element event
   */
  resumeAutoSlideShow() {
    // use remaining time to set timeout
    autoSlideShow[this.el.id].currentTimeId = window.setTimeout(this.runAutoSlideShow, autoSlideShow[this.el.id].remainingTime);
    autoSlideShow[this.el.id].timeIds.push(autoSlideShow[this.el.id].currentTimeId);
    autoSlideShow[this.el.id].state = 3;
  }
}
