export const globals = {

  /**
     * Wrapper function which will allowing easy mocking from jasmine
     * allow mocking for testing
     * @param elem
     * @returns {CSSStyleDeclaration}
     */
  getComputedStyle(elem) {
    return getComputedStyle(elem);
  },
  /**
     * Get the window navigator parameter
     * @returns {Navigator|WorkerNavigator}
     */
  getNavigator() {
    return window.navigator;
  },
};

/**
 * blank function
 */
export function noop() {
}

/**
 * Converting array like structure into array
 * @param arg
 * @returns {*}
 */
export function asArray(arg) {
  if (!arg) {
    return [];
  }
  return Array.prototype.slice.call(arg);
}

/**
 * undefine or null check
 * @param arg
 * @returns {boolean}
 */
export function isDefined(arg) {
  return arg !== null && arg !== undefined;
}

/**
 * Verify of html element
 * @param o
 * @returns {boolean}
 */
export function isElement(o) {
  if (!o) {
    return false;
  }
  return (
    typeof HTMLElement === 'object' ? o instanceof HTMLElement :
      typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string');
}

/**
 * Calculate the BOX width and height of the element received as argument,
 * that is width + padding + margin + border
 * @param elem
 * @returns {{width: number, height: number}}
 */
export function calculateBoxDimension(elem) {
  if (!isElement(elem)) {
    throw new TypeError('elem argument must be an html element.');
  }
  // Get First child height to calculate offset to the next
  const style = globals.getComputedStyle(elem);
  const marginLeft = parseInt(style.marginLeft, 10);
  const marginRight = parseInt(style.marginRight, 10);
  const marginTop = parseInt(style.marginTop, 10);
  const marginBottom = parseInt(style.marginBottom, 10);
  const width = elem.offsetWidth + marginLeft + marginRight;
  const height = elem.offsetHeight + marginTop + marginBottom;
  return {
    width, height, marginLeft, marginRight, marginTop, marginBottom,
  };
}

/**
 * Based on browsers, get the available transform parameters.
 * @param elem
 * @returns {{}}
 */
export function getTransformInfo(elem) {
  if (!isElement(elem)) {
    throw new TypeError('elem argument must be an html element.');
  }
  const transformNames = ['scaleX', 'skewY', 'skewX', 'scaleY', 'translateX', 'translateY'];
  const style = globals.getComputedStyle(elem);
  // transform will contains a string like 'matrix(1, 0, 0, 1, 50, 0)'
  const transform = style.transform || style.webkitTransform || style.mozTransform;
  const values = transform.match(/\w+\((.*)\)/)[1].split(',');
  const transformInfo = {};
  transformNames.forEach((v, i) => {
    transformInfo[v] = values[i].trim();
  });
  return transformInfo;
}

/**
 * Wrapper for translate3d function to either scroll vertically or horizontally.
 * @param elem
 * @param coords
 */
export function translate(elem, ...coords) {
  const anotherElem = elem;
  if (!isElement(anotherElem)) {
    throw new TypeError('elem argument must be an html element.');
  }
  const [x, y, z] = coords;
  const transfValue = `translate3d(${x || 0}px,${y || 0}px,${z || 0}px)`;
  anotherElem.style.transform = transfValue;
  anotherElem.style.webkitTransform = transfValue;
  anotherElem.style.mozTransform = transfValue;
}

/**
 * Checking if device is touch enabled or not
 * @param event
 * @returns {*|boolean}
 */
export function isTouchEnabled(event) {
  return isDefined(event) && isDefined(event.touches) && event.touches.length === 1;
}

/**
 * Where mouse button is down or not
 * @param event
 * @returns {*|boolean}
 */
export function isMousedown(event) {
  return isDefined(event) && isDefined(event.which) && event.which === 1;
}

export function setA11State(elem, enabled, deep) {
  if (!isElement(elem)) {
    return;
  }
  const focusableNodeNames = {
    A: true,
    AREA: true,
    BUTTON: true,
    SELECT: true,
    OBJECT: true,
    TEXTAREA: true,
    INPUT: true,
    LI: true,
  };
  if (focusableNodeNames[elem.nodeName]) {
    elem.setAttribute('tabindex', enabled ? '0' : '-1');
    elem.setAttribute('aria-hidden', `${!enabled}`);
  }
  if (deep) {
    for (let i = 0; i < elem.children.length; i += 1) {
      setA11State(elem.children[i], enabled, deep);
    }
  }
}

export function handleSpaceEnter(event, target) {
  if (event.keyCode === 32 || event.keyCode === 13) {
    target.click();
    event.preventDefault();
  }
}
