/**
 * Name: Davis Yi, Daniel Sarmiento
 * Date: 12/18/2017
 * Description:
 *  Horizontal Carousel is a Carousel component that visualize list of element inline
 *  and let user scroll them through horizontally.
 */

import Carousel, {
  ScrollType,
  HORIZONTAL,
} from './Carousel';
import { calculateBoxDimension } from '../util';
import template from '../templates/partials/carousel/HorizontalCarouselCollection.hbs';

require(`../scss/carousel/${process.env.ENTRY_POINT}/horizontalCarousel.scss`);

const DELTA_THRESHOLD = 25;
export default class HorizontalCarousel extends Carousel {
  constructor(opts) {
    // Call parent class constructor
    super(Object.assign({}, opts, { template, type: HORIZONTAL }));
  }

  render() {
    super.render();

    const hasChildren = this.childrenView.length > 0;
    if (hasChildren) {
      // Get First child height to calculate offset to the next
      this.handleSizing();
    }
    return this;
  }

  onWindowLoad() {
    const { display } = getComputedStyle(this.el);
    // Get first child width to calculate offset to the next, only if parent element is visible
    this.childSize.childWidth = (display === 'none') ? this.opts.childWidth : calculateBoxDimension(this.childrenView[0]).width;
    super.onWindowLoad();
  }

  /**
     *  doSizing is resize height of the carousel
     */
  doSizing() {
    if (this.childrenView.length === 0) {
      return;
    }
    const { childWidth } = this.childSize;

    // get integer value of carousel Wrapper height
    const carouselWrapperWidth = this.el.offsetWidth - ((this.opts.swatch) ? (2 * this.buttons[0].offsetWidth) : this.buttons[0].offsetWidth);

    // set carousel wrapper width again
    this.carouselWrapper.style.width = `${carouselWrapperWidth}px`;

    // Align right button to right most of carousel
    this.buttons[1].parentElement.style.right = (this.opts.swatch) ? `${this.buttons[1].clientWidth / 2}px` : `${this.buttons[1].clientWidth}px`;

    // calculate minimum number of child view that can fit in one page (with margin)
    let childPerPage = Math.floor(carouselWrapperWidth / childWidth);

    // see if there is empty space in the page at the end with minimum number of child view
    const extraChild = Math.floor(carouselWrapperWidth - (childWidth * childPerPage));

    // get Readonly computed style of each child
    const { marginRight, paddingRight } = getComputedStyle(this.childrenView[0]);

    // see if one more child can fit at the end if we do not count margin bottom of last child
    childPerPage += Math.floor(extraChild /
            (childWidth - parseInt(marginRight, 10) - parseInt(paddingRight, 10)));
    childPerPage = childPerPage || 1;
    const maxPage = Math.floor(this.childrenView.length / childPerPage) + ((this.childrenView.length % childPerPage) > 0 ? 1 : 0);
    // Resize carousel Wrapper height and scroller's width
    this.scroller.style.width = `${childPerPage * (maxPage + 1) * childWidth}px`;
    // if page is true then calculate maximum number of child view can fit in the each page and number of pages
    if (this.opts.scrollType === ScrollType.PAGE) {
      this.page.max = maxPage;

      // Need to update current: if resize happens and if childPerPage is different now
      if ((this.page.current > 1) && (this.page.childPerPage !== childPerPage)) {
        this.page.current = Math.floor(this.page.lastItemShown / childPerPage) + ((this.page.lastItemShown % childPerPage) > 0 ? 1 : 0);
      }

      // set new maximum page and child per page
      this.page.childPerPage = childPerPage;

      this.lastItemShown();
    } else {
      // else next/prev button move one element by one element
      this.page.max = this.childrenView.length - 1;
    }

    // if IE 11 manually set height of button to make in center
    if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0) {
      this.buttons[0].style.height = `${this.el.clientHeight}px`;
      this.buttons[1].style.height = `${this.el.clientHeight}px`;
    }
  }

  calculateOffsetForPage() {
    const { current, childPerPage } = this.page;
    return { x: -this.childSize.childWidth * (current - 1) * childPerPage, y: 0 };
  }

  // this.scrollerPos, posX, posY, this.opts.swipeVelocity
  calculateNewScrollerPosition({ posX }) {
    const offsetX = this.scrollerPos.start.x - posX;
    const { translateX } = this.scrollerPos.transform;
    const newPositionValue = Object.assign({}, this.scrollerPos.newPositionValue);
    // calculate the new offet, scroller position - mouse offet
    newPositionValue.x = Number(translateX) - (offsetX * this.opts.swipeVelocity);
    return newPositionValue;
  }

  calculateCurrentPageForSwipe({
    scrollerPos, childSize, carouselWrapper, childLength, childPerPage,
  }) {
    const { newPositionValue } = scrollerPos;
    const { x } = newPositionValue;
    const { childWidth } = childSize;
    const { clientWidth } = carouselWrapper;

    let page;
    // if theres no previous page to show set page to the first page index
    if (x > 0) {
      page = 1;
    } else if (Math.abs(x) > ((childLength * childWidth) - clientWidth)) {
      // else if bottom of the last child is too low, bring it back
      page = this.page.max;
    } else {
      // else track to the nearest page
      // calculate nearest page since the drop and shoe it
      page = Math.round(Math.abs(x / (childWidth * childPerPage))) + 1;
    }
    return page;
  }

  spaceForAllChildren() {
    if (this.childrenView && this.childrenView.length > 0) {
      const carouselWrapperWidth = this.el.offsetWidth - (this.buttons[0].offsetWidth * 2);
      const { width, marginRight } = calculateBoxDimension(this.childrenView[0]);
      return carouselWrapperWidth >= ((width * this.childrenView.length) - marginRight);
    }
    return true; // disable buttons when no children available
  }


  /**
     * [EVENT LOGIC]
     * mouseMoveEventListener excutes when user start to make a move
     * @param { EVENT } event
     */
  pointerMoveEventListener(event) {
    if (this.touchEnabled) {
      const deltaX = event.touches[0].pageX - this.scrollerPos.start.x;
      if (Math.abs(deltaX) > DELTA_THRESHOLD) {
        // default touch behavior allows dragging elements both vertical and horizontal axis we need to prevent that
        event.preventDefault();
      }
    }

    super.pointerMoveEventListener(event);
  }
}
