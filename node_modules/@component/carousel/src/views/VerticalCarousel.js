/**
 * Name: Davis Yi, Daniel Sarmiento
 * Date: 12/18/2017
 * Description:
 *  Vertical Carousel is a Carousel component that visualize list of element inline
 *  and let user scroll them through vertically.
 */

import Carousel, {
  ScrollType,
  VERTICAL,
} from './Carousel';
import { calculateBoxDimension } from '../util';
import template from '../templates/partials/carousel/VerticalCarouselCollection.hbs';

require(`../scss/carousel/${process.env.ENTRY_POINT}/verticalCarousel.scss`);

export default class VerticalCarousel extends Carousel {
  /**
     *
     * @param {*} opts
     *  1. el - holder DOM element or id. (required)
     *  2. childrenView - list of DOM element that should be populated as child view
     *  3. page - boolean flag to decide whether user want to scroll page by page
     *            or element by element ( default: true )
     *  4. event - automatically add event listener of click, and touch (default: true)
     *  4. size - size of icon ( full, huge, medium, small, tiny )
     */
  constructor(opts) {
    // Call parent class constructor
    super(Object.assign({}, opts, { template, type: VERTICAL }));
  }

  render() {
    super.render();
    const hasChildren = this.childrenView.length > 0;
    if (hasChildren) {
      this.handleSizing();
    }
    return this;
  }

  onWindowLoad() {
    // Get First child height to calculate offset to the next
    const { width, height } = calculateBoxDimension(this.childrenView[0]);
    this.el.style.width = `${width}px`;
    this.childSize.childHeight = height;
    super.onWindowLoad();
  }


  /**
     *  doSizing is resize height of the carousel
     */
  doSizing() {
    if (this.childrenView.length === 0) {
      return;
    }
    const { childHeight } = this.childSize;

    // get integer value of carousel Wrapper height
    const carouselWrapperHeight = this.el.offsetHeight - (this.buttons[0].offsetHeight * 2);
    this.carouselWrapper.style.height = `${carouselWrapperHeight}px`;

    // Enable the button if the height of elements inside of carousel is longer
    if (this.carousel.clientHeight > this.carouselWrapper.clientHeight) {
      this.buttons[1].removeAttribute('disabled');
      this.buttons[1].classList.add('enabled');
    }

    // if page is true then calculate maximum number of child view can fit
    // in the each page and number of pages
    if (this.opts.scrollType === ScrollType.PAGE) {
      // calculate minimum number of child view that can fit in one page (with margin)
      let childPerPage = Math.floor(carouselWrapperHeight / childHeight);

      // see if there is empty space in the page at the end with minimum number of child view
      const extraChild = Math.floor(carouselWrapperHeight - (childHeight * childPerPage));

      // get Readonly computed style of each child
      const { marginBottom, paddingBottom } = getComputedStyle(this.childrenView[0]);
      // see if one more child can fit at the end if we do not
      // count margin bottom of last child
      childPerPage += Math.floor(extraChild /
                (childHeight - parseInt(marginBottom, 10) - parseInt(paddingBottom, 10)));
      childPerPage = childPerPage || 1;
      // set new maximum page and child per page
      this.page.childPerPage = childPerPage;
      this.page.max = Math.ceil((this.childrenView.length) / this.page.childPerPage);
    } else if (this.opts.scrollType === ScrollType.ITEM) {
      // else next/prev button move one element by one element
      this.page.max = this.childrenView.length;
    }
  }

  calculateOffsetForPage() {
    const { current, childPerPage } = this.page;
    return { y: -this.childSize.childHeight * (current - 1) * childPerPage, x: 0 };
  }

  calculateNewScrollerPosition({ posY }) {
    const offsetY = this.scrollerPos.start.y - posY;
    const { translateY } = this.scrollerPos.transform;
    const newPositionValue = Object.assign({}, this.scrollerPos.newPositionValue);
    // calculate the new offet, scroller position - mouse offset
    newPositionValue.y = Number(translateY) - (offsetY * this.opts.swipeVelocity);
    return newPositionValue;
  }

  calculateCurrentPageForSwipe({
    scrollerPos, childSize, carouselWrapper, childLength, childPerPage,
  }) {
    const { newPositionValue } = scrollerPos;
    const { y } = newPositionValue;
    const { childHeight } = childSize;
    const { clientHeight } = carouselWrapper;

    let page;
    // if there's no previous page to show set page to the first page index
    if (y > 0) {
      page = 1;
    } else if (Math.abs(y) > ((childLength * childHeight) - clientHeight)) {
      // else if bottom of the last child is too low, bring it back
      page = this.page.max;
    } else {
      // else track to the nearest page
      // calculate nearest page since the drop and shoe it
      page = Math.round(Math.abs(y / (childHeight * childPerPage))) + 1;
    }
    return page;
  }

  spaceForAllChildren() {
    if (this.childrenView && this.childrenView.length > 0) {
      const carouselWrapperWidth = this.el.offsetHeight - (this.buttons[0].offsetHeight * 2);
      const { height, marginBottom } = calculateBoxDimension(this.childrenView[0]);
      return carouselWrapperWidth >= ((height * this.childrenView.length) - marginBottom);
    }
    return true; // disable buttons when no children available
  }

  /**
     * [EVENT LOGIC]
     * mouseDownEventListener excutes when user start to mouse on the screen enabled device
     * @param { EVENT } event
     */
  pointerDownEventListener(event) {
    if (this.touchEnabled) {
      event.preventDefault();
    }
    super.pointerDownEventListener(event);
  }

  /**
     * [EVENT LOGIC]
     * mouseMoveEventListener excutes when user start to make a move
     * @param { EVENT } event
     */
  pointerMoveEventListener(event) {
    if (this.touchEnabled) {
      event.preventDefault();
    }
    super.pointerMoveEventListener(event);
  }
}
