{
  const Logger = require('./Logger');
  // Method - returns the current date object from the client's machine
  // @return  {dateObject}
  const getCurrentDate = function () {
    return new Date();
  };

    // Method - prepend zero, if num is less than 10
    // @param   {number} num
    // @return  {string}
  const padZero = function (n) {
    let num = n;
    num = parseInt(num, 10);
    return (num < 10) ? `0${num}` : `${num}`;
  };


    // Method - format 24 hours to 12 hours
    // @param   {number} hours
    // @return  {string}
  const formatHours = function (hours) {
    return hours.toString().replace(/^(\d{1,2})/, (h) => {
      let hrs = h;
      hrs = parseInt(hrs, 10);
      if (hrs > 12) {
        return padZero(hrs - 12);
      }
      return padZero(hrs);
    });
  };

    /* time format = 12 0r 24 */
  const convertTimeFormat = function (time, timeFormat) {
    let timeVal = [];
    if (timeFormat === '12') {
      let hour = '';
      let minute = '';
      let timeformat = '';
      let min = '';
      if (typeof time !== 'string') {
        throw new Error('convertTimeFormat called without proper time');
      }
      timeVal = time.split(':');
      if (timeVal.length < 1) {
        throw new Error('convertTimeFormat called without proper time');
      }
      hour = timeVal[0];
      minute = timeVal[1];
      if (hour >= 12) {
        timeformat = 'pm';
        hour %= 12;
      } else {
        timeformat = 'am';
      }

      if (hour === 0 || hour === '0' || hour === '00') {
        hour = 12;
      }

      min = `:${minute}`;
      minute = (minute > 0) ? min : ':00';
      timeVal = hour + minute + timeformat;
    } else {
      // NOTE: The time entered must at least be a string value
      if (typeof time !== 'string' || (time.length && time.length === 0)) {
        return time;
      }
      let hours = time.match(/^(\d+)/);
      let minutes = time.match(/:(\d+)/);
      let AMPM = time.match(/[a-zA-Z]*$/);
      if (hours) {
        hours = Number(hours[1]);
      } else {
        hours = 12;
      }
      if (minutes) {
        minutes = Number(minutes[1]);
      } else {
        minutes = 0;
      }
      if (AMPM) {
        AMPM = AMPM[0].toLowerCase();
      } else {
        AMPM = 'am';
      }


      if (AMPM === 'pm' && hours < 12) {
        hours += 12;
      }
      if (AMPM === 'am' && hours === 12) {
        hours -= 12;
      }
      let sHours = hours.toString();
      let sMinutes = minutes.toString();
      if (hours < 10) {
        sHours = `0${sHours}`;
      }
      if (minutes < 10) {
        sMinutes = `0${sMinutes}`;
      }
      timeVal = (`${sHours}:${sMinutes}`);
    }
    return timeVal;
  };


    // Method - return the formatted date
    // @param   {string} frmt
    // @param   {dateObject} date - Optional; defaults to current date if not provided
    // @return  {string}
  const formatDate = function (frmt, date) {
    const dt = date || new Date();
    const d = dt.getDate();
    const m = dt.getMonth() + 1;
    const y = dt.getFullYear();
    const hh = dt.getHours(); // 24 hr format
    const h = formatHours(hh); // 12 hr format
    const mi = dt.getMinutes();
    const time = `${hh}:${mi}`;
    const p = convertTimeFormat(time, '12'); // get period value
    const a = p.substr(p.length - 2).toUpperCase();
    const month = ['January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December',
    ];


    return frmt.replace(/dd|m(m)?|MM|yy(yy)?|h(h)?|a/g, (i) => {
      switch (i) {
        case 'dd':
          return (d < 10) ? `0${d}` : `${d}`;
        case 'mm': // month
          return (m < 10) ? `0${m}` : `${m}`;
        case 'yy':
          return (`${y}`).substring(2, 4);
        case 'yyyy':
          return `${y}`;
        case 'h': // 12hr format
          return `${h}`;
        case 'hh': // 24hr format
          return `${hh}`;
        case 'm': // minutes
          return (mi < 10) ? `0${mi}` : `${mi}`;
        case 'a': // am or pm
          return `${a}`;
        case 'MM': // month full name
          return `${month[m - 1]}`;
        default:
          return '';
      }
    });
  };
    // Method - return the formatted date from 'n' number of days using the date specified
    // @param   {string} frmt
    // @param   {number} days
    // @param   {dateObject} date - Optional; defaults to current date if not provided
    // @return  {string}
  const getDayAfter = function (frmt, days, date) {
    const dt = date || getCurrentDate();
    dt.setDate(dt.getDate() + days);
    return formatDate(frmt, dt);
  };

    // Method - returns the current date as a formatted string
    // @param   {string} frmt
    // @return  {string}
  const getToday = function (frmt) {
    return formatDate(frmt, getCurrentDate());
  };
    /* convert date format to wed 14 2014 */
  const convertDateFormat = function (opDate, openTime, closeTime) {
    let operationDate = opDate;
    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    let date = '';
    let dateObj = '';
    let day = '';
    let month = '';
    let operationTime = '';
    let splitDate = '';
    if (operationDate) {
      splitDate = operationDate.split('-');
      if (splitDate[0].indexOf('*') !== -1) {
        operationDate = 'Closed';
        operationTime = '';
      } else {
        dateObj = new Date(splitDate[0], splitDate[1] - 1, splitDate[2]);
        date = dateObj.getDate();
        day = dateObj.getDay();
        month = dateObj.getMonth();
        if ((openTime === '' && closeTime === '') || (openTime === '' || closeTime === '')) {
          operationDate = 'Closed';
          operationTime = '';
        } else if ((openTime.indexOf('*') !== -1 && closeTime.indexOf('*') !== -1) ||
                    (openTime.indexOf('*') !== -1 || closeTime.indexOf('*') !== -1)) {
          operationDate = `${weekdays[day]}, ${months[month]} ${date}`;
          operationTime = ': Closed';
        } else {
          operationDate = `${weekdays[day]}, ${months[month]} ${date}`;
          operationTime = `: ${convertTimeFormat(openTime, '12')} - ${convertTimeFormat(closeTime, '12')}`;
        }
      }
    } else {
      operationDate = 'Not Available';
      operationTime = '';
    }
    return `<b>${operationDate}</b>${operationTime}`;
  };


    // Method - to convert date to another timezone based on given offset value.
    // @param   {number} offset
    // @param   {number} serverTime
    // @return  {string}
  const convertTimeZone = function (offset, serverTime) {
    const d = new Date(serverTime);
    // convert to msec
    // add local time zone offset
    // get UTC time in msec
    const utc = d.getTime() + (d.getTimezoneOffset() * 60000);

    // create new Date object for different city
    // using supplied offset
    const nd = new Date(utc + (3600000 * offset));

    // return time as a string
    return formatDate('yyyy-mm-dd', nd);
  };

    // Method - to convert date to another timezone based on given offset, time and date format.
    // @param   {number} offset  - Note: timezone suffix e.g: EST, PST, EDT etc. should be appended by the caller.
    // @param   {number} time (in msec if UTC).
    // @param   {boolean} isUtc (true if 'time' is in UTC format else false)
    // @param   {date} dateFormatToReturn to return
    // @return  {string}
  const convertToTimeZoneGivenOffset = function (offset, serverTime, isUtc, dateFormatToReturn) {
    let dStr = '';

    try {
      let d = '';
      let utc = '';
      let tmpD = '';

      // convert the given time to UTC by adding the local time zone offset
      if (isUtc && !Number.isNaN(Number(serverTime))) {
        const timeInMS = Number(serverTime);
        tmpD = new Date(timeInMS);
        utc = timeInMS + (tmpD.getTimezoneOffset() * 60000);
      } else {
        tmpD = new Date(serverTime);
        utc = tmpD.getTime() + (tmpD.getTimezoneOffset() * 60000);
      }

      if (!Number.isNaN(Number(utc))) {
        d = new Date(utc + (3600000 * offset));

        // return time as a string
        // Format date to given 'dateFormatToReturn' or else send default format
        if (dateFormatToReturn) {
          dStr = formatDate(dateFormatToReturn, d);
        } else {
          dStr = formatDate('mm/dd/yy h:m a', d);
        }
      }
    } catch (ex) {
      Logger.error('Error converting the timezone to given offset: ', ex);
    }

    return dStr;
  };


    // Method - to check the given year is leap year.
    // @param   {number} - the year to be checked.
    //

  const checkLeapYear = function (year) {
    return !(year % 4 !== 0 || (year % 100 === 0 && year % 400 !== 0));
  };


  module.exports = {
    getToday,
    getDayAfter,
    formatDate,
    formatHours,
    convertTimeFormat,
    padZero,
    convertDateFormat,
    convertTimeZone,
    convertToTimeZoneGivenOffset,
    checkLeapYear,
  };
}
