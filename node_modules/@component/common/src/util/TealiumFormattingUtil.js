class Format {
  constructor(field) {
    this.field = field;
  }
}

class FormatString extends Format {
  transform() {
    return [String(this.field || '')];
  }
}

class FormatCurrency extends Format {
  getNumber() {
    if (typeof this.field === 'string') {
      const num = this.field.replace(/[,]+/g, '');
      return Number.isNaN(Number(num)) === true ? '0' : num;
    }
    return this.field || '0';
  }
  transform() {
    return [
      Number(this.getNumber())
        .toFixed(2)
        .toString(),
    ];
  }
}

class FormatNumber extends Format {
  transform() {
    // eslint-disable-next-line no-bitwise
    return [(this.field | 0).toString()];
  }
}

class FormatBoolean extends Format {
  getBool() {
    if (['', null, undefined].indexOf(this.field) !== -1) {
      return '';
    } else if (typeof this.field === 'boolean') {
      return this.field;
    } else if (typeof this.field === 'string') {
      try {
        return typeof JSON.parse(this.field) === 'boolean' ? this.field : '';
      } catch (e) {
        return '';
      }
    } else {
      return '';
    }
  }
  transform() {
    return [String(this.getBool())];
  }
}

class FormatIsNotEmpty extends Format {
  getField() {
    this.field = ['', null, undefined].indexOf(this.field) === -1 ? this.field : '';
    return this.field;
  }
  transform() {
    return [String(this.getField())];
  }
}

class UnformatValue extends Format {
  getField() {
    if (this.field && this.field.constructor.name === 'Array') {
      return this.field.shift().toString();
    }
    return '';
  }

  transform() {
    return this.getField();
  }
}

export const STRING = 'string';
export const CURRENCY = 'currency';
export const NUMBER = 'number';
export const BOOL = 'bool';
export const NOT_EMPTY = 'notempty';
export const UNFORMAT = 'unformat';

export function format(field, type = STRING) {
  switch (type) {
    case STRING:
      return new FormatString(field).transform();
    case CURRENCY:
      return new FormatCurrency(field).transform();
    case NUMBER:
      return new FormatNumber(field).transform();
    case BOOL:
      return new FormatBoolean(field).transform();
    case NOT_EMPTY:
      return new FormatIsNotEmpty(field).transform();
    case UNFORMAT:
      return new UnformatValue(field).transform();
    default:
      throw new Error('Format not available');
  }
}
