// #MODULE - ServiceHandler
// > Author: Mike Byrnes
// >
// > Create Date: January 6, 2014
// >
// ##DESCRIPTION: This module will handle executing service calls and processing the response through the callback.
{
  const $ = require('jquery');
  const CacheManager = require('./CacheManager');
  // ### A public object that can be used to make a service request or as a callback.
  // ### Example usage:
  //    var serviceHandler = new ServiceHandler({
  //                  serviceContext: factory,
  //                  service: factory.getData,
  //                  cache: 'session', // accepted values: 'session' or 'persistent'  Default is no cache
  //                  cacheExpiration: 15 //time in minutes.  Default is on expiration
  //                  }),
  //      requestParameters = {parameter1: "one", parameter2: "two"},
  //      options = {key: "cacheKey"} //Accepted options are key with a value of what key to store in the cache
  //    serviceHandler.sendRequest(requestParameters, options);
  function ServiceHandler(attrs) {
    const attributes = attrs || {};

    this.context = this;
    this.serviceContext = attributes.serviceContext;
    this.service = attributes.service;

    function getCacheMethod(type) {
      if (attributes.cache) {
        const method = CacheManager[type + attributes.cache.charAt(0).toUpperCase() + attributes.cache.slice(1)];
        if (method) {
          return method;
        }
      }

      throw new Error(`Unable to retrieve cache method ${type} for cache type: ${attributes.cache}`);
    }

    this._getKey = function (key) {
      const method = getCacheMethod('get');
      return method(key);
    };

    this._setKey = function (key, data) {
      const method = getCacheMethod('set');
      method(key, data, attributes.cacheExpiration);
    };

    this._getAttribute = function (attribute) {
      return attributes[attribute];
    };

    this._getCallback = function (cacheKey) {
      const _this = this;
      const callback = {
        success(response, argument) {
          if (cacheKey) {
            this._setKey(cacheKey, response);
          }
          _this.success(response, argument);
        },
        failure: _this.failure,
        context: _this.context, // should be pointing to ServiceHandler instance
        arg: _this.arg,
        responseType: _this.responseType,
      };

      return callback;
    };
  }

  ServiceHandler.prototype = {
    responseType: 'JSON',

    // ###Flag to decide whether to hide the previous error when a new call is initiated
    hideErrorContainerOnStart: true,

    handleStart() {
      // override in subclass
    },

    handleComplete() {
      // override in subclass
    },

    // ###Method processSuccessResponse(response, argument) public method to handle anything to do with a successful response
    // This method should be overridden at the instance level
    // > parameters
    // >
    // + *response* - the response passed to the callback
    // + *argument* - the argument specified as part of the callback
    processSuccessResponse(response, argument) { // eslint-disable-line no-unused-vars
      // Needs to be overridden by subclass
    },

    // ###Method processFailureResponse(response, argument) public method to handle anything to do with a failure response
    // This method should be overridden at the instance level
    // > parameters
    // >
    // + *response* - the response passed to the callback
    // + *argument* - the argument specified as part of the callback
    processFailureResponse(response, argument) { // eslint-disable-line no-unused-vars
      // Needs to be overridden by subclass
      this.showError();
    },

    // ###Method processErrorResponse(response, argument) public method to handle anything to do with a error response
    // This method should be overridden at the instance level
    // > parameters
    // >
    // + *response* - the response passed to the callback
    // + *argument* - the argument specified as part of the callback
    processErrorResponse(response, argument) { // eslint-disable-line no-unused-vars
      // Needs to be overridden by subclass
    },

    hasErrors() {
      // Needs to be overridden by subclass
      return false;
    },

    errorContainer: null,

    failOnError: true,

    errorClass: 'errorContainer',

    _getErrorHtml(error, tds) {
      let techDetails = tds;
      let errorHtml = this._errorHtml.replace('%errorClass%', this.errorClass).replace('%error%', error);

      if (techDetails) {
        // If tech details is an object, convert it to a string
        if (typeof techDetails !== 'string') {
          techDetails = `${techDetails}`;
        }
        errorHtml += `<!-- ${techDetails.replace(/--/g, '**')}-->`;
      }

      return errorHtml;
    },

    showError(err, techDetails) {
      const error = err || this._unknownErrorMessage;

      if (this.supressErrors === false) {
        const eContainer = this._getErrorContainer();
        const errorHtml = this._getErrorHtml(error, techDetails);

        if (eContainer) {
          eContainer.innerHTML = errorHtml;
          eContainer.style.display = 'block';
        } else {
          $(document).trigger({
            type: 'unhandledError',
            error,
            techDetails,
          });
        }
      }
    },

    _start() {
      const eContainer = this.errorContainer;

      if (eContainer && this.hideErrorContainerOnStart) {
        this._getErrorContainer().style.display = 'none';
      }

      this.handleStart();
    },

    success(response, argument) {
      try {
        const hasError = this.hasErrors(response, argument);

        if (hasError && this.failOnError) {
          this.processErrorResponse(response, argument);
        } else {
          this.processSuccessResponse(response, argument);
        }
      } finally {
        this._complete();
      }
    },

    failure(response, argument) {
      try {
        this.processFailureResponse(response, argument);
      } finally {
        this._complete();
      }
    },

    _complete() {
      this.handleComplete();
    },

    _unknownErrorMessage: 'Sorry, we could not process your request. Please try again later.',

    _errorHtml: "<div class='%errorClass%' aria-live='polite'>%error%</div>",

    _getErrorContainer() {
      if (this.errorContainer && typeof this.errorContainer === 'string') {
        this.errorContainer = document.getElementById(this.errorContainer);
      }

      return this.errorContainer;
    },

    sendRequest(request, opts) {
      let cacheData;

      const options = opts || {};

      try {
        this._start();

        if (this._getAttribute('cache') && options.key) {
          cacheData = this._getKey(options.key);
        }

        if (cacheData) {
          this.success(cacheData, this.arg);
        } else {
          this.service.call(this.serviceContext, this._getCallback(options.key), request);
        }
      } catch (e) {
        this.failure(
          {
            error: e,
          },
          this.arg,
        );
      }
    },

    supressErrors: false,
  };

  module.exports = ServiceHandler;
}
