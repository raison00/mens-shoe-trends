// #MODULE - Image Utils
// > Author: Joseph Acosta
// >
// > Create Date: June 10, 2014
// >
// ##DESCRIPTION: A module that provides some image utilities for manipulating images
{
  const $ = require('jquery');
  const logger = require('./Logger');
  const defaultAnimationDelay = 0;
  const defaultMaxZoom = 5;
  const defaultMinZoom = 1 / 5;
  const zoomConstants = {
    IN: 0,
    OUT: 1,
    RESET: 2,
  };
  let units = 'px';

  // ###Method initOptions( options ) a method that initializes an options object
  //
  // > parameters
  // >
  // + *options* - the options object to check and initialize
  //
  // > returns
  // >
  // + an empty options object or the options object
  function initOptions(options = {}) {
    // any units passed in
    if (typeof options.units !== 'undefined') {
      units = options.units;
    }

    return options;
  }

  // ###Method - getElement(ele) method to take a string or dom object or jquery wrapped object
  // and return a jquery wrapped object
  // probably useful elsewhere, this will check if the string has a leading # for jquery and
  // add one if it does not exist
  //
  // > parameters
  // >
  // + *ele* - this can be a string or a jquery wrapped object or a dom reference
  //
  // > returns
  // >
  // + a jquery wrapped object.
  function getElement(ele) {
    let result;
    if (typeof ele === 'string' && !/^#/.test(ele)) {
      result = $(`#${ele}`);
    } else {
      result = $(ele);
    }
    return result;
  }

  // ###Method getScaleRatio( width, height, scaleRatio ) a method that returns height and widht scaled amounts
  //
  // > parameters
  // >
  // + *width* - the width to scale
  // + *height* - the height to scale
  // + *scaleAmt* - the amount to scale
  //
  // > returns
  // >
  // + an object with the new width and height scale amounts
  function getScaleRatio(width, height, scaleRatio) {
    let w;
    let h;
    if (Number.isNaN(Number(scaleRatio))) {
      return {};
    }

    if (scaleRatio === 0) {
      w = width;
      h = height;
    } else if (scaleRatio < 0) {
      w = width / scaleRatio;
      h = height / scaleRatio;
    } else {
      // must be greater than 0
      w = width * scaleRatio;
      h = height * scaleRatio;
    }
    return {
      width: Math.abs(w),
      height: Math.abs(h),
    };
  }

  // ###Method scale(objA, objB, scaleAmt) a method to scale obj b
  //
  // > parameters
  // >
  // + *objA* - the object to scale from
  // + *objB* - the object to be scaled
  // + *scaleAmt* - the amount to scale
  //
  // > returns
  // >
  // + objB as a jquery wrapped object and it's width and height set
  function scale(objA, objB, scaleAmt) {
    if (Number.isNaN(Number(scaleAmt))) {
      return objB;
    }
    const refA = getElement(objA);
    const refB = getElement(objB);

    const sr = getScaleRatio(refA.width(), refA.height(), scaleAmt);
    if (typeof sr.width !== 'undefined' && typeof sr.height !== 'undefined') {
      refB.width(Math.floor(sr.width));
      refB.height(Math.floor(sr.height));
    }
    return refB;
  }

  // ###Method - zoomOut( zoomLeft, zoomTop, image, zoomContainer )
  //
  // > parameters
  // >
  // + *zoomLeft* - the offset left
  // + *zoomTop* - the offset top
  // + *image* - the image to be zoomed in on
  // + *zoomContainer* - the zoom container box
  //
  // > returns
  // >
  // + nothing
  function zoomOut(zoomLeft, zoomTop, image, zoomContainer, options = {}) {
    // Get a reference to the image data object so we
    // don't need to keep retreiving it.
    const imageData = image.data();
    let zoomedImage;

    initOptions(options);

    // Check to see if we have reached the max zoom
    // or if the image is currently animating.
    // If so, just return out.
    if (imageData.zoom > imageData.minZoom || image.is(':animated')) {
      // Increase the zoom.
      imageData.zoom--;
    }

    // get the image and then zoom in on the image
    if (typeof zoomContainer !== 'undefined') {
      zoomedImage = $('img', zoomContainer);
      if (typeof zoomedImage !== 'undefined') {
        zoomedImage = scale(zoomContainer, zoomedImage, imageData.zoom);
        if (zoomContainer.width() === zoomContainer.height() && image.height() !== image.width()) {
          // scalefacor
          zoomedImage.height(image.height() / (zoomedImage.width() / image.width()));
        }

        imageData.left = (imageData.left - zoomLeft) / (zoomedImage.width() / image.width());
        imageData.top = (imageData.top - zoomTop) / (zoomedImage.height() / image.height());

        // fix me the width of the zoomed image vs width of real image
        // need to map the zoomed region
        zoomedImage.css({
          marginLeft: Math.round(imageData.left) + units,
          marginTop: Math.round(imageData.top) + units,
        });
      }
    }
  }

  // ###Method - zoomIn( zoomLeft, zoomTop, image, zoomContainer )
  //
  // > parameters
  // >
  // + *zoomLeft* - the offset left
  // + *zoomTop* - the offset top
  // + *image* - the image to be zoomed in on
  // + *zoomContainer* - the zoom container box
  //
  // > returns
  // >
  // + nothing
  function zoomIn(zoomLeft, zoomTop, image, zoomContainer, opts) {
    // Get a reference to the image data object so we
    // don't need to keep retreiving it.
    const imageData = image.data();
    let zoomedImage;

    const options = initOptions(opts);
    const imageSelector = options.imageSelector || 'img';

    // Check to see if we have reached the max zoom
    // or if the image is currently animating.
    // If so, just return out.
    if (imageData.zoom < imageData.maxZoom || image.is(':animated')) {
      // Increase the zoom.
      imageData.zoom++;
    }

    // get the image and then zoom in on the image
    if (typeof zoomContainer !== 'undefined') {
      zoomedImage = $(imageSelector, zoomContainer);
      if (typeof zoomedImage !== 'undefined') {
        zoomedImage = scale(zoomContainer, zoomedImage, imageData.zoom);
        if (zoomContainer.width() === zoomContainer.height() && image.height() !== image.width()) {
          // scalefacor
          zoomedImage.height(image.height() * (zoomedImage.width() / image.width()));
        }
        imageData.left = (imageData.left - zoomLeft) * (zoomedImage.width() / image.width());
        imageData.top = (imageData.top - zoomTop) * (zoomedImage.height() / image.height());

        // fix me the width of the zoomed image vs width of real image
        // need to map the zoomed region
        zoomedImage.css({
          marginLeft: Math.round(imageData.left) + units,
          marginTop: Math.round(imageData.top) + units,
        });
      }
    }
  }

  // ###Method - zoomReset( image )
  //
  // > parameters
  // >
  // + *image* - the image to be zoomed in on
  // + *options* - so far just the ability to pass in a zoom level
  //
  // > returns
  // >
  // + nothing
  function zoomReset(image, options = {}) {
    // Get a reference to the image data object so we
    // don 't need to keep retreiving it.
    const imageData = image.data();
    let animateDelay = defaultAnimationDelay;

    initOptions(options);

    // Reset the image data.
    imageData.zoom = typeof options.zoom !== 'undefined' ? options.zoom : 1;
    imageData.width = imageData.originalWidth;
    imageData.height = imageData.originalHeight;

    imageData.top = 0;
    imageData.left = 0;

    if (typeof options.animationDelay !== 'undefined') {
      animateDelay = options.animationDelay;
    }

    // Animate the zoom.
    image.animate(
      {
        width: imageData.width,
        height: imageData.height,
        left: imageData.left,
        top: imageData.top,
      },
      animateDelay,
    );
  }

  // ###Method updateScene7ImageURL( imgURL, width, height ) updates the width and height of a scene7 url
  //
  // > parameters
  // >
  // + *imgURL* - the scene7 image url
  // + *width* - the new width
  // + *height* - the new height - optional
  //
  // > returns
  // >
  // + the updated url
  function updateScene7ImageURL(imgURL, width, height) {
    let result = imgURL.replace(/wid=(\d*)/, `wid=${width}`);
    if (typeof height === 'undefined') {
      result = result.replace(/&hei=(\d*)/, '');
    } else {
      result = result.replace(/hei=(\d*)/, `hei=${height}`);
    }
    return result;
  }

  // ###Method - init(image, imageContainer, options)
  //
  // > parameters
  // >
  // + *image* - the image to be zoomed in on
  // + *imageContainer* - the container for the image
  // + *options* - any options that need to be passed in
  //
  // > returns
  // >
  // + an object that has an updated image reference that is a wrapped jquery object
  // and and updated reference to the image container which is also a wrapped jquery object,
  // also containing a view offset.
  function init(img, imgContainer, options) {
    let mazZoom = defaultMaxZoom;
    let minZoom = defaultMinZoom;
    const image = getElement(img);
    const imageContainer = getElement(imgContainer);

    // append the image to the container again, just in case :)
    imageContainer.append(image);

    // force a height & width
    image.height(image.height());
    image.width(image.width());

    // Set an explicit height / width on the view based
    // on the initial size of the image.
    image.width(imageContainer.width());
    image.height(imageContainer.height());

    logger.log(`ImageUtils image dimensions: ${image.width()} ${image.height()}`);

    // process options
    if (typeof options !== 'undefined') {
      if (typeof options.mazZoom !== 'undefined' && !Number.isNaN(Number(options.mazZoom))) {
        mazZoom = options.mazZoom;
      }
      if (typeof options.minZoom !== 'undefined' && !Number.isNaN(Number(options.minZoom))) {
        minZoom = options.minZoom;
      }
    }

    // As the user mouses over the view, we can get the
    // mouse coordinates in terms of the page; we need
    // to be able to translate those into VIEW-based
    // X and Y cooridates. As such, let's get the offset
    // of the view as our base 0x0 coordinate.
    //
    // NOTE: We are doing this here so that we do it once,
    // rather than every time the mouse moves.
    const viewOffset = imageContainer.offset();

    // setup image data
    // + zoom is the current zoom level
    // + maxZoom is the maximum zoom level
    image.data({
      zoom: 1,
      maxZoom: mazZoom,
      minZoom,
      top: 0,
      left: 0,
      parentOffsetLeft: imageContainer.position() ? imageContainer.position().left : 0,
      parentOffsetTop: imageContainer.position() ? imageContainer.position().top : 0,
      width: image.width(),
      height: image.height(),
      originalWidth: image.width(),
      originalHeight: image.height(),
    });

    return {
      image,
      imageContainer,
      viewOffset,
    };
  }

  // ###Method - zoomImage( zoomLeft, zoomTop, image, zoomRegionBox, zoomDirection )
  //
  // > parameters
  // >
  // + *zoomLeft* - the offset left
  // + *zoomTop* - the offset top
  // + *image* - the image to be zoomed in on
  // + *zoomContainer* - the zoom container box
  // + *zoomDirection* - the direction to zoom which is imageUtils.zoomConstants property
  // + *options* - any options to be passed through
  //
  // > returns
  // >
  // + nothing
  function zoomImage(zoomLeft, zoomTop, image, zoomContainer, zoomDirection, options) {
    switch (zoomDirection) {
      case zoomConstants.IN:
        this.zoomIn(zoomLeft, zoomTop, image, zoomContainer, options);
        break;
      case zoomConstants.OUT:
        this.zoomOut(zoomLeft, zoomTop, image, zoomContainer, options);
        break;
      case zoomConstants.RESET:
        this.zoomReset(image, options);
        break;
      default:
        this.zoomReset(image, options);
        break;
    }
  }

  module.exports = {
    getElement,
    init,
    scale,
    zoomImage,
    zoomIn,
    zoomOut,
    zoomReset,
    zoomConstants,
    updateScene7ImageURL,
  };
}
