/* eslint no-bitwise: 0 */
/* eslint no-extend-native: 0 */
/* eslint no-mixed-operators: 0 */
// #MODULE - StringUtil
// > Authors: Dev 1, Dev 2, Brenda Jin
// >
// > Create Date: November 6, 2013
// >
// ##DESCRIPTION: This module will handle string manipulation. For numbers manipulation that does not
// include special characters like '$' signs, please see MathUtil.js

{
  const $ = require('jquery');
  const _ = require('underscore');
  const truncate = function (text, minChar, maxChar, addon) {
    let str = '';
    const _addon = addon || '';

    if (text.length < maxChar) {
      str = text;
    } else {
      for (let i = maxChar; i > minChar; i--) {
        if (text.charAt(i - 1) === ',') {
          str = text.substring(0, i - 1) + _addon;
        } else if (text.charAt(i) === ' ') {
          str = text.substring(0, i) + _addon;
        }
      }
    }

    return str;
  };
  /* checking valid or in valid input */
  const isEmptyString = function (input) {
    if (input !== undefined && input !== null && input !== '') {
      return true;
    }
    return false;
  };

  // ###Method: will replace the pattern of $1,$2,$3,etc in str for the amount of args passed in.
  const repMult = function (str, ...args) {
    let retStr = str;
    if (args.length > 0) {
      for (let i = 0; i < args.length; i++) {
        retStr = retStr.replace(`$${i + 1}`, args[i]);
      }
    }
    return retStr;
  };

  const vPostCode = function (str, ctry) {
    const country = ctry || 'US';
    switch (country.toUpperCase()) {
      default:
        return /(^\d{5}$)|(^\d{5}-\d{4}$)/.test(str);
    }
  };

  // ###Method - isEmpty(val) public method that takes in variable and returns false if it is
  // not a string with a length greater than zero.  IMPORTANT TO NOTE: This function treats a string that only contains
  // white-space as "empty".
  //
  // > parameters
  // >
  // + *str* - this is the string that we want analyze for empty
  //
  // > returns
  // >
  // + boolean true/false depending on outcome of analyzing str
  const isEmpty = function (str) {
    if (str) {
      return str === null || str.length === 0 || /^\s+$/.test(str);
    }
    return true;
  };

  // ###Method - toPrice( str ) is a public method that can take either a number or string, and returns a value in the format `$XX.XX`
  // **Important**: this function does that accept strings that cannot be parsed with parseFloat()
  const toPrice = function (str) {
    const myPrice = parseFloat(str);
    if (Number.isNaN(Number(myPrice))) {
      throw new Error('string argument must be parseable with parseFloat()');
    }

    return `$${myPrice.toFixed(2)}`;
  };

  // ###Method - getURLParameter(name, querystring )
  // Grabs a value out of the querystring based on the name passed in.  The querystring parameter is optional, and if not passed
  // (undefined) then it will attempt to grab the string from the window.location object.
  //
  // > parameters
  // >
  // + *name* - The name of the key that contains the value.
  // + *querystring* (optional) - a querystring patterned string or undefined.
  //
  // > returns
  // >
  // + string or null.  This is the value of "name" or null if name is not found.  Null differentiates from found but blank.
  const getURLParameter = function (name, querystring) {
    const qs = typeof querystring !== 'undefined' ? querystring : window.location.search;

    const regex = (new RegExp(`[?|&]${name}=([^&;]+?)(&|#|;|$)`).exec(`?${qs}`) || ['', ''])[1].replace(/\+/g, '%20');
    // if querystring is iso encoded catch error
    try {
      return decodeURIComponent(regex) || null;
    } catch (e) {
      return regex || null;
    }
  };
  // get parameter value from hash string
  const getURLParameterFromHash = function (name, testHash) {
    const hash = testHash || window.location.hash;
    const regex = new RegExp(`[#|&]${name}=([^&;]+?)(&|#|;|$)`);
    return decodeURIComponent((regex.exec(hash) || ['', ''])[1].replace(/\+/g, '%20')) || null;
  };

  /**
   * This is to get query string map for the given query string or taken from browser URL
   * with option for case sensitive/insensitive parameter name.
   *
   * Usage:
   * 1) getQueryStringMap("LinkShareId=1&PartnerID=2&BannerId=3&partnerId=4")
   *    Output: {linkshareid: "1", partnerid: "4", bannerid: "3"}
   * 2) getQueryStringMap("LinkShareId=1&PartnerID=2&BannerId=3&partnerId=4", true)
   *    Output: {LinkShareId: "1", PartnerID: "2", BannerId: "3", partnerId: "4"}
   */
  const getQueryStringMap = function (queryString, isCaseSensitive) {
    const qsArray = (queryString || window.location.search.slice(1)).split('&');

    return _.chain(qsArray)
      .map((item) => {
        if (item) {
          const paramMap = item.split('=');
          if (!isCaseSensitive && !_.isEmpty(paramMap)) {
            paramMap[0] = paramMap[0].toLowerCase();
          }
          return paramMap;
        }
        return undefined;
      })
      .compact()
      .object()
      .value();
  };

  /**
   * Method to get decoded value with possible character set.
   * Default decoding is UTF-8 and if it fails then with ISO-8859-1.
   */
  const getDecodedValue = function (value) {
    let decodedValue = '';

    if (value) {
      try {
        decodedValue = decodeURIComponent(value || '');
      } catch (ex) {
        // If UTF-8 decoding fails try with ISO-8859-1.
        decodedValue = unescape(value || '');
      }
    }

    return decodedValue;
  };

  /**
   * Method to get decoded query parameter value with possible character set.
   * Default decoding is UTF-8 and if it fails then with ISO-8859-1.
   */
  const getDecodedParamValue = function (param) {
    let qsMap;
    let paramValue;

    if (param) {
      qsMap = getQueryStringMap();
      paramValue = getDecodedValue(qsMap[param] || '');
    }

    return paramValue;
  };

  // ###Method - highlightInsert(ele, value, pattern, optionalCompareText, optionalClassList )
  // This method will highlight matching text within the passed in element "ele", given the "value" submitted
  //
  // > parameters
  // >
  // + *ele* - This is the element that contains the text.  This assumes that the text is in the "innerText" property of the element
  // + *value* - This is the value submitted that we want to match against
  // + *pattern* - This is the RegEx of the "value" as submitted by the caller, because the caller might manipulate pattern:
  // + e.g. To match the start of string versus anywhere in string
  // + *optionalCompareText* - This is an optional parameter to compare the "value" against, otherwise will use ele.text().
  // + This is here because the caller might have manipulated the string to match against: e.g. replacement characters like accented characters
  // + *optionalClassList* - This is an optional, space delimited string of extra CSS classes that will be applied to the highlight element
  //
  // > returns
  // >
  // + Nothing.  This changes the text within "ele"
  function highlightInsert(ele, value, pattern, optionalCompareText, optionalClassList) {
    const orig = $(ele).text();
    const txt = optionalCompareText || orig;
    let i = 0;
    const arr = [];
    let st;
    let ed;
    const classes = `filter-match${optionalClassList ? ` ${optionalClassList}` : ''}`;

    while (txt.substr(i).search(pattern) >= 0) {
      st = txt.substr(i).search(pattern) + i;
      ed = st + value.length;

      const sub = `<span data-id="highlight" class="${classes}">${orig.substring(st, ed)}</span>`;

      arr[arr.length] = orig.substring(i, st);
      arr[arr.length] = sub;

      i = ed;
    }

    arr[arr.length] = orig.substring(ed);

    $(ele).html(arr.join(''));
  }

  // ###Method - hightlightRemove(container)
  // This is the counter method to "highlightInsert".  It will look for the pattern of highlighting as inserted by
  // "highlightInsert" and then remove that pattern, but only within the given "container" element
  //
  // > parameters
  // >
  // + *container* - This is the container element that contains highlighted text at any level of descendant.
  // + Must be expressed as a selector (i.e. with "#" for id, "." for class or tagname for tags).
  //
  // > returns
  // >
  // + Nothing.  This changes the text within "ele"
  function highlightRemove(container) {
    $(`${container} span[data-id="highlight"]`)
      .contents()
      .unwrap();
  }

  // ###Method - escapeForRegEx( str )
  // When we have a string that will be used for a RegExp, we must first escape any special characters in the string
  // (characters that have special meaning for RegExp: i.e. "\", ".", etc).  This method will take in the string
  // and then return the string back, but with the right characters escaped.
  //
  // > parameters
  // >
  // + *str* - This is the string that needs escaping
  //
  // > returns
  // >
  // + String - Returns the same string value but with the special characters replaced for RegExp
  function escapeForRegEx(str) {
    return str.replace(/([()[{*+.$^\\|?])/g, '\\$1');
  }

  // ##Method - toCapitalize(str)
  // This method will convert the String input in to toCapitalize.
  function toCapitalize(str) {
    const title = str.charAt(0).toUpperCase() + str.substr(1).toLowerCase();
    return title;
  }

  // ###Method - maskCreditCard( toMask, mask )
  // Public method to mask any string except last four digit.
  // The logic to mask string except last four digits is very specific to creditcard hence this method is named maskCreditCard.
  //
  // > parameters
  // >
  // + *toMask* : *String* - String that needs to be masked
  // + *mask* : *String* - String to mask with.
  //
  // > returns
  // >
  // + A masked string.
  function maskCreditCard(toMask, mask) {
    const arr = [];
    let myMask = mask;
    if (!toMask || typeof toMask !== 'string' || (myMask && typeof myMask !== 'string')) {
      throw new Error('Incorrect parameters passed.');
    }
    if (toMask.length > 4) {
      myMask = myMask || '*';
      arr[toMask.length - 4] = undefined;
      return arr.join(myMask) + toMask.substr(toMask.length - 4, 4);
    }
    return toMask;
  }

  function generateUuid() {
    let d = new Date().getTime();
    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = ((d + Math.random() * 16) % 16) | 0;
      d = Math.floor(d / 16);
      return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
    return uuid;
  }

  // Immediate Invoke Function (IIFE)
  // This function will be used add methods to String object as soon as StringUtils.js is loaded
  // Since StringUtils.js is part of McomBase.js it will get executed before any page specfic modules are loaded
  //
  // > parameters
  // + none
  //
  // > returns
  // + none
  //
  (function () {
    // Checking if trim method is available as part of String Object or not and add it if not available
    // Internally it is calling jQuery's trim (http://api.jquery.com/jquery.trim/) method.
    if (typeof String.prototype.trim !== 'function') {
      String.prototype.trim = function () {
        return $.trim(this);
      };
    }

    // POLYFILL: check if there is an "endsWidth" function in native String() and add it if not
    if (typeof String.prototype.endsWith !== 'function') {
      String.prototype.endsWith = function (searchString, position) {
        const subjectString = this.toString();
        let myPosition = position;
        if (myPosition === undefined || myPosition > subjectString.length) {
          myPosition = subjectString.length;
        }
        myPosition -= searchString.length;
        const lastIndex = subjectString.indexOf(searchString, myPosition);
        return lastIndex !== -1 && lastIndex === myPosition;
      };
    }

    // POLYFILL: check if there is an "startsWith" function in native String() and add it if not
    if (typeof String.prototype.startsWith !== 'function') {
      String.prototype.startsWith = function (searchString, position) {
        let myPosition = position;
        myPosition = myPosition || 0;
        return this.substr(myPosition, searchString.length) === searchString;
      };
    }
  }());

  function firstWordOccurrence(str) {
    if (!str || !_.isString(str)) {
      return str;
    }

    return str.match(/(^\w*)/)[1];
  }

  function firstNumberOccurrence(str) {
    if (!str || !_.isString(str)) {
      return str;
    }

    return str.match(/(^\d*)/)[1];
  }

  // like 8e8124d4-7ab2-401a-bf12-69fb70cb6f4c for guid
  function stringWithDashPattern(str) {
    if (!str || !_.isString(str)) {
      return str;
    }

    return str.match(/(^[\w-]*)/)[1];
  }

  module.exports = {
    generateUuid,
    truncate,
    replaceMultiple: repMult,
    validatePostalCode: vPostCode,
    isEmpty,
    isEmptyString,
    toPrice,
    getURLParameter,
    getURLParameterFromHash,
    getQueryStringMap,
    getDecodedValue,
    getDecodedParamValue,
    highlightRemove,
    highlightInsert,
    escapeForRegEx,
    toCapitalize,
    maskCreditCard,
    firstWordOccurrence,
    firstNumberOccurrence,
    stringWithDashPattern,
  };
}
