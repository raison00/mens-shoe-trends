// #MODULE - Segmentation
// > Author: ??, ??
// >
// > Create Date: ??
// >
// ##DESCRIPTION: AMD module to do client side segmentation checking and splitting.
// Simplest usage is:
// Segmentation.detect( experiments, callback );
// where the experiments is a list of your experiments [ 320, 321, 322 ]
// and the callback will take an argument of which experiment from that group 'won'
{
  const $ = require('jquery');
  const Cookie = require('./Cookie');
  // const Globals = require('./Globals');
  const Logger = require('./Logger');
  const Segmentation = {
    cookieName: 'SEGMENT',
    expCookieName: 'SEED',
    ajaxTimeout: 3000,
    service: undefined,
  };

  Segmentation.decode = function (ck) {
    const result = {};
    let cookie = ck;

    try {
      cookie = $.parseJSON(cookie).EXPERIMENT;

      for (let i = 0, l = cookie.length; i < l; i++) {
        result[cookie[i]] = cookie[i];
      }
    } catch (e) {
      Logger.error(e);
    }

    return result;
  };

  // reset experiment running -- remove cookie and get new one
  Segmentation.reset = function (callback) {
    Cookie.remove(this.cookieName);
    this.data = undefined;
    this.fetch(callback);
    return undefined;
  };

  Segmentation.getCookie = function () {
  /*  const loc = window.location;

    // implement manual cookie override for testing purposes
    const param = loc.search.match(/[?|&]experiment=([^&]+)/) || loc.search.match(/[?|&]segment=([^&]+)/);

    if (param) {
      Logger.log('Overriding experimentation.');
      return this.decode(`{"EXPERIMENT":[${param[1]}]}`);
    }

    // get regular cookie value
    const cookie = Cookie.get(this.cookieName);

    if (cookie) {
      return this.decode(cookie);
    }

    return undefined; */
  };

  // make call to Experementation Framework service to get
  // SEGMENT cookie with list of segments/experiments for
  // current session. after fetching cookie, will process
  // queue and call optional callback passed.
  Segmentation.fetch = function (callback) {
  /*  const self = this;
    const sid = Cookie.get(this.expCookieName) ? `?sid=${Cookie.get(this.expCookieName)}` : '';
    if (typeof this.service !== 'undefined') {
      $.ajax({
        url: this.service,
        url: `${this.service}/campaign/sync${sid}`,
        dataType: 'jsonp',
        cache: true,
        timeout: this.ajaxTimeout,
      }).always((resp) => {
        let experiments;
        // do we care about text status or errors?
        // , textStatus, errorThrown) {

        // resp could be the jqXhr object or data
        // so we want to weed out the jqXhr object
        if (typeof resp !== 'undefined' && typeof resp.always === 'undefined') {
          experiments = JSON.stringify(resp);
          Cookie.set('SEGMENT', experiments); // , { expires: expireTime });
          self.set(self.decode(experiments));
        } else {
          self.set(self.getCookie() || {});
        }
        if (self.queue) {
          for (let i = 0, l = self.queue.length; i < l; i++) {
            self.queue[i](self.data);
          }

          delete self.queue;
        }
*/
    if (typeof callback === 'function') {
      // callback(self.data);
      callback();
    }
    /*  });
    } */
  };

  Segmentation.set = function (data) {
    this.data = data;
  };

  // fetch list of current session segments/experiments.
  // returns hash of experiment ids as first argument to
  // callback passed.
  //
  // example:
  //    Segmentation.list( function ( list ) {
  //        console.log( list ); // { 9:9, 71:71, 11:11 }
  //    } );
  //
  /*  Segmentation.list = function (callback) {
    // there are already request running, queue call
    if (this.queue) {
      if (typeof callback === 'function') {
        this.queue.push(callback);
      }

      return undefined;
    }

    // get segments from cookie
    if (!this.data) {
      this.set(this.getCookie());
    }

    // segments already parsed
    if (this.data) {
      return typeof callback === 'function' && callback(this.data);
    }

    // create queue, to avoid multiple request to server
    this.queue = [];

    // no segment cookie, fetch it
    this.fetch(callback);

    return undefined;
  }; */

  // detect current segment/experiment running from list of
  // passed segments/experiments.
  //
  // example:
  //    Segmentation.detect( [220, 221, 222], function ( experiment ) {
  //        // 220 or 221 or 222 or undefined (in case of failed framework)
  //        console.log( experiment );
  //    } );
  //
  Segmentation.detect = function (segs, callback) {
  //  let segments = segs;
    console.log(segs);
    /*  Segmentation.service = Globals.getValue('props.experimentationHost');

    // Added by Mercury DEV team to turn-off frontend experiments
    // if QE_TEST=mercury1_92_false, do not call experimentation API and remove SEGMENT cookie
    // this is used by QA teams to do regression test when client side experimentation is TURNED OFF
    const mercuryCookie = Cookie.get('QE_TEST');
    if (mercuryCookie && mercuryCookie.includes('mercury1_92_false')) {
      Cookie.remove('SEGMENT');
    if (typeof callback === 'function') {
      callback();
    }
    return;
    }

    Segmentation.list((list) => {
      // split string segments value
      if (typeof segments === 'string') {
        segments = segments.split(/[\s,]+/);
      }

      // convert all input to array
      if (!$.isArray(segments)) {
        segments = [segments];
      }

      // lookup for fist matching value in 2 arrays
      for (let i = 0, l = segments.length; i < l; i++) {
        if (list[segments[i]]) {
          return typeof callback === 'function' && callback(segments[i]);
        }
      }

      if (typeof callback === 'function') {
        callback();
      }
      return undefined;
    });  */
    if (typeof callback === 'function') {
      callback();
    }
  };

  module.exports = {
    detect: Segmentation.detect,
  };
}
