// #MODULE - Analytics
// > Author: Joseph Acosta
// >
// > Create Date: December 18, 2013
// >
// ##DESCRIPTION: AMD module that abstracts an analytics implementation via pub sub.
{
  const _ = require('underscore');
  const stringUtil = require('./StringUtil');
  // ###Namespace - querystring
  // This establishes a namespace for the following functions for code organization and readability.
  //* Description:* This namespace contains some basic procedures to use a single parameter called 'tdp' in place
  // of multiple tracking parameters.
  //
  // As far as possible, this allows backwardly-compatible functionality - existing Coremetrics
  // parameters can be passed in a URL and processed from there. e.g.:
  //
  // > ...&cm_kws_ac=calvin+k...
  //
  // or they can be included in the 'tdp' parameter:
  //
  // > ...&tdp=cm_kws_ac[mvEquator]calvin+k...
  //
  // Using a generic 'tdp' parameter allows us to include multiple tracking values in a single
  // parameter, and ensure that only the single 'tdp' parameter is excluded from Akamai cache keys:
  //
  // > ...&tdp=cm_kws_ac[mvEquator]calvin+k[mvSeparator]cm_src[mvEquator]PROS_PDPZ1_Pos2...
  //
  // The 'tdp' parameter should NOT be used to pass the following 'base' Coremetrics parameters:
  //
  // + cm_re
  // + cm_sp
  // + cm_mmc
  // + cm_lm_mo
  let querystring = {};

  /* The tracking key name that will be used in primary querystring, e.g. 'tdp=' */
  const trackingDataParam = 'tdp';
  /* Equivalent of "&" within tdp */
  const mvSeparator = '~x';
  /* Equivalent of "=" within tdp */
  const mvEquator = '~z';

  function getQueryString(qs) {
    return typeof qs !== 'undefined' ? qs : window.location.search;
  }

  // ###Method - encodeTrackValue(str, removeKey)
  // This is a private helper function to take in the custom querystring based tracking value from "setTrackingValue/getTrackingValue"
  // and loop through it to uriEncode the values again.  Assumes a method throughout of attempting to only encode the values and not
  // allow url illegal characters in the keys.
  //
  // > parameters
  // >
  // + *str* - This is the string to encode the values from.  Assumes the custom pattern
  // + *removeKey* - Removes this key/value from the overall value when rebuilding and sending back.
  //
  // > returns
  // >
  // + string.  This is the correctly encoded custom string now, minus the removeKey/value
  function encodeTrackValue(str, removeKey) {
    const p = str.split(mvSeparator);
    let x;
    let ret = '';
    for (let i = 0; i < p.length; i++) {
      x = p[i].split(mvEquator);
      if (x[0] !== removeKey) {
        ret += x[0] + mvEquator + encodeURIComponent(x[1]) + (i < p.length - 1 ? mvSeparator : '');
      }
    }
    if (ret.endsWith(mvSeparator)) {
      ret = ret.substring(0, ret.lastIndexOf(mvSeparator));
    }

    return ret;
  }

  // ###Method - setTrackingValue ( name, value, querystring )
  // This public method will return a reformatted querystring with the name/value added to the
  // custom tracking parameter.  A note on querystring: be aware that it will attempt location.search if not passed in.
  // This assumes a window object. It is up to the caller to ensure they are in an environment with the window object and if there
  // is a doubt, then pass in '' (blank string) as a default.
  //
  // > parameters
  // >
  // + *name* - The name of the key to add.
  // + *value* - The value of the key that is being added.  This will be uriEncoded.
  // + *querystring* - (optional). This is an optional string that is a formmetted querystring.  If not provided, function
  // + will attempt to get from the window.location object.
  //
  // > returns
  // >
  // + string.  This is the reformatted querystring
  querystring.getTrackingValue = function (trackingVariable, query) {
    querystring = getQueryString(query);

    // First check if the parameter was passed directly in the URL
    const value = stringUtil.getURLParameter(trackingVariable, querystring);
    if (value !== null) {
      return value;
    }
    // If not, retrieve it from the 'tdp' multi-value parameter
    const mvValue = stringUtil.getURLParameter(trackingDataParam, querystring);
    if (mvValue === null) {
      return null;
    }
    const mvSubs = mvValue.split(mvSeparator);
    for (let j = 0; j < mvSubs.length; j++) {
      const items = mvSubs[j].split(mvEquator);
      if (items[0] === trackingVariable) {
        return items[1];
      }
    }

    return null;
  };

  // ###Method - setTrackingValue ( name, value, querystring )
  // This public method will return a reformatted querystring with the name/value added to the
  // custom tracking parameter.  A note on querystring: be aware that it will attempt location.search if not passed in.
  // This assumes a window object. It is up to the caller to ensure they are in an environment with the window object and if there
  // is a doubt, then pass in '' (blank string) as a default.
  //
  // > parameters
  // >
  // + *name* - The name of the key to add.
  // + *value* - The value of the key that is being added.  This will be uriEncoded.
  // + *querystring* - (optional). This is an optional string that is a formmetted querystring.  If not provided, function
  // + will attempt to get from the window.location object.
  //
  // > returns
  // >
  // + string.  This is the reformatted querystring
  querystring.setTrackingValue = function (name, val, query) {
    // STEP: Make the "querystring" an optional parameter and get from window object if not passed in
    querystring = getQueryString(query);

    // STEP: escape the value so that it is URL ready
    const value = encodeURIComponent(val);

    // STEP: Set local vars for use in this function
    let mvValue = stringUtil.getURLParameter(trackingDataParam, querystring);
    const newValue = name + mvEquator + value;
    let outValue = '';

    // STEP: logic matrix for the various use cases
    if (mvValue === null) {
      // BRANCH: 'tdp' parameter doesn't exist in URL...this expects the stringUtil funtion to return null for missing key
      // STEP: figure out if we need to prepend '&' and set up key=value
      outValue = `${(querystring.length > 0 ? `${querystring}&` : '') + trackingDataParam}=${newValue}`;
    } else {
      // BRANCH: 'tdp' parameter exists, and may or may not include this value

      // STEP: first encode the existing values in string again, and remove the update key
      mvValue = encodeTrackValue(mvValue, name);

      // STEP: now we rebuild the incoming querystring, but with the updated 'trackingDataParam' value
      const qsparts = querystring.split('&');
      let qs = '';
      for (let i = 0; i < qsparts.length; i++) {
        if (qsparts[i].indexOf(`${trackingDataParam}=`) === -1) {
          qs += `${qsparts[i]}&`;
        }
      }

      // STEP: now put back together the return value.
      outValue = `${qs + trackingDataParam}=${mvValue}${mvValue.length ? mvSeparator : ''}${newValue}`;
    }
    return outValue;
  };

  // ###Method - buildQueryMap ( query )
  // This public method will return a hash object containing each parameter from a query string,
  // being each property of the object a key/value from the querystring.
  //
  // > parameters
  // >
  // + *query* - (optional). This is an optional string that is a formmatted querystring.  If not provided, function
  // + will attempt to get from the window.location object.
  //
  // > returns
  // >
  // + string.  This is the reformatted querystring
  querystring.buildQueryMap = function (query) {
    return _.chain((query || getQueryString().slice(1)).split('&'))
      .map((item) => {
        if (item) {
          return item.split('=');
        }
        return undefined;
      })
      .compact()
      .reduce((mem, item) => {
        const memo = mem;
        if (!memo[item[0]]) {
          memo[item[0]] = item[1];
        }
        return memo;
      }, {})
      .value();
  };

  module.exports = querystring;
}
