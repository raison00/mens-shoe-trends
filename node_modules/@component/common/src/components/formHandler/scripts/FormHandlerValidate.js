// #MODULE - FormHandlerValidate
// > Author: Kristine Lai + Lochan Chhetri
// >
// > Create Date: January 2016
// >
// ##DESCRIPTION:
// Supporting module for FormHandlerMain
// Validates client-side form error

// require 'require' to allow dynamically requiring of additional modules based on conditional checks
{
  const $ = require('jquery');
  const _ = require('underscore');
  const validationManager = require('../../validation/ValidationManager');
  const formHandlerUtil = require('./FormHandlerUtil');
  require('./inputMask');
  const FormHandlerValidate = function (formId) {
    // config can be passed in at instantiation
    const config = {};

    // references to the form element
    config.formElement = typeof formId === 'string' ? $(`#${formId}`) : formId;

    // formId without the # sign  (just text portion)
    config.formId = config.formElement.attr('id');
    config.formName = config.formElement.attr('name');

    config.formLevelError = false;
    config.formLevelErrorTemplate = false;

    this.onSubmitCallback = false;
    this.onSubmit = function (cb) {
      this.onSubmitCallback = cb;
    };

    this.onErrorCallback = false;
    this.onError = function (cb) {
      this.onErrorCallback = cb;
    };

    this.onCancelCallback = false;
    this.onCancel = function (cb) {
      this.onCancelCallback = cb;
    };

    config.rulesHash = {};

    // return these for public API:

    this.formData = config;

    // main reference to <input> or <select> elements, input type, messages(recovery, instructional), and errors
    this.inputData = {};
  }; // end of instance module

  function checkForError(n, value) {
    let name = n;
    const formData = this.formData;
    const inputName = name;
    const inputData = this.inputData;

    const validateFieldHash = inputData[inputName].rules;
    inputData[inputName].hasError = false;
    Object.keys(validateFieldHash).forEach(() => {});
    const keys = Object.keys(validateFieldHash);
    for (let itr = 0; itr < keys.length; itr += 1) {
      const validateField = keys[itr];
      const rules = _.omit(validateFieldHash[validateField], ['maskPattern']);

      if (validateField === 'passwordConfirm' && _.has(rules, 'equal')) {
        name = rules.equal;
        if (this.formData.formElement[0][name]) {
          rules.equal = this.formData.formElement[0][name].value;
        } else {
          throw new Error(`Cannot find form element with name ${rules.equal}`);
        }
      }

      inputData[inputName].errors = validationManager.validate(inputName, value, rules);

      if (inputData[inputName].errors.length > 0) {
        inputData[inputName].hasError = true;
        inputData[inputName].currentValidateField = validateField;
        break;
      }
    }

    if (inputData[inputName].hasError) {
      $(`#${formData.formId}`).trigger('form_error', [
        inputData[inputName].currentValidateField,
        inputData[inputName].elementId,
        inputData[inputName].errors[0].validator,
        inputData[inputName].optional,
      ]);
    } else if (inputData[inputName].errors.length === 0) {
      inputData[inputName].hasError = false;

      $(`#${formData.formId}`).trigger('form_valid', [inputData[inputName].elementId, inputData[inputName].optional]);
    }
  }

  function formIsValid() {
    this.formErrorArray = [];
    Object.keys(this.inputData).forEach((key) => {
      const el = $(`#${this.inputData[key].elementId}`);

      if (el.length > 0) {
        _.bind(checkForError, this)(key, el.val());
        if (this.inputData[key].hasError) {
          this.formData.formLevelError = true;
          el.attr('aria-invalid', 'true');
          this.formErrorArray.push({
            title: this.inputData[key].title,
            elementId: el.attr('id'),
            errorPointers: [this.inputData[key].currentValidateField, this.inputData[key].errors[0].validator], // validateField, validator
          });
        }
      }
    });

    if (this.formErrorArray.length === 0) {
      this.formData.formLevelError = false;
    }

    return !this.formData.formLevelError;
  }

  function bindEvent() {
    const _this = this;
    if (this.useBlur === true) {
      $(_this.inputSelector, this.formElement)
        .not('input[type=submit]')
        .each(function () {
          const el = $(this);
          let event = 'blur';

          if (el.is('select')) {
            event = 'blur change';
          }

          el.on(event, (e) => {
            const obj = $(e.target);
            const name = obj.attr('name');
            const inputValue = obj.val();
            _this.inputData[name].visited = true;

            // equivalent of checkForError( name, inputValue, this );
            _.bind(checkForError, _this)(name, inputValue);
          });
        });
    }

    $('.submit').on('click', (e) => {
      e.preventDefault();
      if (_.bind(formIsValid, _this)()) {
        if (_this.onSubmitCallback) {
          _this.onSubmitCallback(_this.formData.formElement);
        } else {
          $(`#${_this.formData.formId}`).submit();
        }
      } else if (_this.onErrorCallback) {
        _this.onErrorCallback(_this.inputData);
      }
    });

    $('.cancel').on('click', (e) => {
      e.preventDefault();
      if (_this.onCancelCallback) {
        _this.onCancelCallback();
      }
    });
  }

  // private helper methods
  // build hash table of each individual form elements, validation rules, recovery text, and instructional text
  function process() {
    const _this = this;

    let rules;
    if (_.isString(_this.formData.rules)) {
      // TODO not sure if this is the best approach?
      // Create a require context for all files in the src/components/formHandler/scripts directory that end in "Rules"
      // https://webpack.github.io/docs/context.html
      const requireContext = require.context('./', false, /Rules$/);

      rules = requireContext(_this.formData.rules);
    } else {
      // Allow direct passing of an object
      rules = _this.formData.rules;
    }

    _this.formData.rulesHash = rules;

    $(_this.inputSelector, _this.formData.formElement)
      .not('input[type=submit]')
      .each(function () {
        const el = $(this);
        const name = el.attr('name');
        const id = formHandlerUtil.escapeId(el.attr('id'));
        const title = el.attr('title');
        const validateField = el.data('validate');

        // build your inputData hash for the selected element
        _this.inputData[name] = {
          visited: false,
          type: el.prop('nodeName'),
          name,
          title,
          elementId: id,
          rules: formHandlerUtil.getNodeByName(validateField, rules),
          hasError: false,
          errors: [],
          validateField,
        };
        // convenience properties:
        _this.inputData[name].optional = !_this.inputData[name].rules;

        // mask form field
        _.each(_this.inputData[name].rules, (rule) => {
          if (rule.maskPattern) {
            el.mask(rule.maskPattern);
          }
        });
      });
  }

  // public methods
  FormHandlerValidate.prototype.init = function (configObject) {
    const {
      onSubmitCallback, onErrorCallback, onCancelCallback, useBlur, rules,
    } = configObject;
    if (onSubmitCallback && typeof onSubmitCallback === 'function') {
      this.onSubmitCallback = onSubmitCallback;
    }

    if (onErrorCallback && typeof onErrorCallback === 'function') {
      this.onErrorCallback = onErrorCallback;
    }

    if (onCancelCallback && typeof onCancelCallback === 'function') {
      this.onCancelCallback = onCancelCallback;
    }

    this.useBlur = useBlur;
    this.formData.rules = rules;
    this.inputSelector = 'input,select,textarea';
    _.bind(bindEvent, this)();
    _.bind(process, this)();
  };

  // FormHandlerValidate.prototype.onErrorCallback = function ( cb ) {

  // };

  FormHandlerValidate.prototype.getFormName = function () {
    return this.formData.formName;
  };

  FormHandlerValidate.prototype.getFormData = function () {
    return this.formData;
  };

  // Provided for user customization if needed
  // Reset form is currently being called from formHandlerMain by default
  FormHandlerValidate.prototype.resetForm = function () {
    const _this = this;
    _this.formData.formLevelError = false;
    Object.keys(_this.inputData).forEach((key) => {
      const el = $(`#${_this.inputData[key].elementId}`);
      if (el.length > 0) {
        el.val('');
        _this.inputData[key].errors = [];
        _this.inputData[key].hasError = false;
      }
    });
  };

  module.exports = FormHandlerValidate;
}
