/* eslint no-underscore-dangle: 0 */
/* jshint smarttabs:true  */
// #MODULE - Panel
// > Author: Raphael Oliveira
// >
// > Create Date: <January 16, 2014>
// >
// ##DESCRIPTION: The requireJS implementation of base/GlobalWidgets.js + panel/panel.js
{
  const $ = require('jquery');
  require('jquery-ui/dialog');

  let count = 1;
  const CONFIG = {
    constraintoviewport: true,
    underlay: 'shadow',
    close: true,
    visible: false,
    draggable: false,
    fixedcenter: false,
    modal: false,
    // Panel base is now 990, will be 999 for modal:true
    zIndex: 990,
    // Left, Right, Bottom, Top, null
    arrow: null,
    tooltip: false,
    closeOnClick: false,
    closeOnScroll: false,
    preventClickOutsideWhileOpen: false,
    minWidth: 0,
    minHeight: 0,
    width: null,
    modalPage: false,
    resizable: false,
  };
  const FIXED_POSITION_ATTRIBUTE = 'fixed';
  const STATIC_POSITION_ATTRIBUTE = 'static';
  const OPEN_EVENT = 'open';
  const CLOSE_EVENT = 'close';

  // CONFIG inside function to prevent having to clone it in another var before extending
  function _getMergedConfiguration(config) {
    return $.type(config === 'object') ? $.extend(true, {}, CONFIG, config) : $.extend(true, {}, CONFIG);
  }

  // ###FUNCT - _getContainer(el) private function
  // Retrieve panel's container or create one if not valid
  //
  // > parameters
  // >
  // + *element* {String or Object} - The String representing the selector which the panel will be appended to.
  // Can be anything a jquery selector accepts, such as #id, .class or even a JS object, such as document.body.
  // If the string is not a selector, will test it as an ID name and if all fails, create the container on-the-fly
  //
  function _getContainer(element) {
    let el = element;
    if (el && $.type(el) === 'string') {
      if ($(el).length) {
        // check if el is a string with a valid jQ selector (or even a jQ object itself) and the element exists
        return el;
      } else if ($(`[id='${el}']`).length) {
        // check if is just plain ID name
        return `#${el}`;
      }
      // el does not exists, create it
      el = el.replace(/^#/, '');
      $(`<div id="${el}" />`).appendTo('body');
      return `#${el}`;
    } else if (el && $.type(el) === 'object') {
      // check if el is a jQ/JS object and the element exists
      if ($(el).length) {
        return el;
      }
    }

    // none of the above returns, therefore create it and give a popup_ id
    count = 1 + count;
    $(`<div id="popup_${count}" />`).appendTo('body');
    return `#popup_${count}`;
  }

  // ###FUNCT - _getRender(el) private function
  // Retrieve panel's place to be rendered or use body if not valid
  //
  // > parameters
  // >
  // + *el* {String or Object} - The String representing the selector which the panel will be rendered to.
  // Can be anything a jquery selector accepts, such as #id, .class or even a JS object, such as document.body.
  // If the string is not a selector, will test it as an ID name and if all fails, use body as default
  //
  function _getRender(el) {
    if ($(el).length) {
      // check if el is a string with a valid jQ selector (or even a jQ object itself) and the element exists
      return $(el);
    } else if ($(`[id='${el}']`).length) {
      // check if is just plain ID name
      return $(`#${el}`);
    }
    // none, use body
    return $(document.body);
  }

  // > If has overlay, zindex will be increased to 999 and overlay will have 998. This way if have any other Panel opened
  // > that has no modal:true, then it will be below the overlay (with zindex base 990) instead of above overlay
  // >
  function _overriddenOpen(...args) {
    $.ui.dialog.prototype.open.apply(this, args);

    if (this.overlay) {
      const zIndex = Number(this.options.zIndex + 9);

      this.overlay.addClass('mask');

      if (zIndex) {
        this.uiDialog.zIndex(zIndex);
        this.overlay.zIndex(zIndex - 1);
      }

      if ($.isNumeric(this.options.underlay)) {
        this.overlay.css('opacity', this.options.underlay);
      }
    }
  }

  function _createJqueryWidget(panelContainer, panelConfig) {
    const $dialog = $(panelContainer).dialog(panelConfig);
    const $widgetInner = $dialog[0];
    const $parent = $widgetInner.parentNode;
    const uiDialog = $dialog.data('uiDialog');
    let closeElement;

    // Move the close button to proper place
    if (panelConfig.close) {
      closeElement = document.createElement('a');
      closeElement.className = 'container-close';
      closeElement.innerHTML = 'Close';
      closeElement.href = '#';
      $(closeElement).appendTo($widgetInner);
    }

    // Remove jquery header DOM
    $($parent)
      .find('.ui-widget-header')
      .detach();

    if (panelConfig.shadow === true) {
      $($parent).addClass('shadow');
    }

    uiDialog.open = _overriddenOpen;

    return {
      widget: uiDialog,
      element: $parent,
      inner: $widgetInner,
    };
  }

  function _getAutoCenterEvents(elementId) {
    const namespace = 'fixedcenterDialog';
    const resizeEvent = `resize.${namespace}_${elementId}`;
    const scrollEvent = `scroll.${namespace}_${elementId}`;
    const events = [];

    events.push(resizeEvent);
    events.push(scrollEvent);

    return events.join(' ');
  }

  // ###Method - autoCenter( event )
  // Private method called to re-center the panel.
  //
  // > parameters
  // >
  // + *event* : *Object* - the event that triggered this call.
  //              It will contain a data object with a reference to the panel
  //
  function autoCenter(event) {
    if ($(window).height() > $(event.data.panel.element).height()) {
      event.data.panel.center();
    }
  }

  // ###Method - enableDisableAutoCentering( event )
  // Private method called to enable or disable the event driven panel centering.
  //
  // > parameters
  // >
  // + *event* : *Object* - the event that triggered this call.
  //              It will contain a data object with attributes:
  //              panel: *Object* - A reference to the panel
  //              enableFixedCenter: *Boolean* - A flag to enable or disable the centering
  //
  function enableDisableAutoCentering(event) {
    const data = event.data;
    const panel = data.panel;
    const autoCenterEvents = _getAutoCenterEvents(panel.element.id);

    if (data.enableFixedCenter) {
      $(window).on(
        autoCenterEvents,
        {
          panel,
        },
        autoCenter,
      );
    } else {
      $(window).off(autoCenterEvents, autoCenter);
    }
  }

  function updateBodyPosition(position) {
    const $body = $('body');
    $body.css({
      position,
    });
  }

  /**
   * If event target is not the panel (or its children)
   * or the element on which the panel aligns itself (or its children),
   * then return true
   * @param  {[type]}  event [description]
   * @return {Boolean}       [description]
   */
  function isEventOutsideOfPanel(event) {
    return (
      event.target !== event.data.panel.element &&
      !$(event.data.panel.element).has(event.target).length &&
      $(event.target)[0] !== $(event.data.panel._option('position').of)[0] &&
      !$($(event.data.panel._option('position').of)[0]).has($(event.target)[0]).length
    );
  }

  const Panel = function P(container, conf) {
    const config = conf;
    const $this = $(this);

    config.autoOpen = config.visible;

    if (config.modalPage) {
      // overwriting some unwanted options for modalPageshow
      // these actions must be done BEFORE creating the widget
      config.closeOnClick = false;
      config.closeOnScroll = false;
      config.fixedcenter = false;
      config.modal = false;
      config.tooltip = false;
      config.arrow = false;
      config.width = null;
      config.height = null;
      config.minHeight = 0;
      config.minWidth = 0;
      config.position = {
        my: null,
        at: null,
        of: null,
        collision: 'none',
        using: null,
      };

      $this.on(OPEN_EVENT, () => {
        updateBodyPosition(FIXED_POSITION_ATTRIBUTE);
      });

      $this.on(CLOSE_EVENT, () => {
        const openModalPanels = $('.bl_modalPage:visible');

        if (openModalPanels && openModalPanels.length > 0) {
          // This check to ensure that the body's position is set to fixed, when we have other opened panels on MEW
          updateBodyPosition(FIXED_POSITION_ATTRIBUTE);
        } else {
          updateBodyPosition(STATIC_POSITION_ATTRIBUTE);
        }
      });
    } else if (config.tooltip) {
      if (config.autoFlip) {
        if (!config.position) {
          config.position = {};
        }

        config.position.collision = 'flip';

        config.position.using = function (css, props) {
          /**
           * props.important returns which direction the tooltip flipped (vertical or horizontal)
           * props.vertical and props.horizontal return which edge is the aligned to the element (top, bottom, right, left)
           */
          const arrowPosition = props[props.important];

          $(this).css(css);

          if (config.arrow) {
            // If the tooltip is supposed to have a arrow, we remove the previous arrow class and add the new one aligned to the new flip position
            $(this).removeClass((index, classes) => (classes.match(/(^|\s)arrow\S+/g) || []).join(' '));

            $(this).addClass(`arrow${arrowPosition.charAt(0).toUpperCase()}${arrowPosition.slice(1)}`);
          }
        };
      }
    }

    // callback function on dialogclose
    if ($.type(config.close) !== 'function' && $.type(config.close) !== 'boolean') {
      config.close = false;
    }

    if (config.height) {
      config.height = parseInt(config.height, 10);
    }

    if (config.underlay === 'shadow') {
      config.shadow = true;
    }
    const widgetObj = _createJqueryWidget(container, config);
    const widgetElement = widgetObj.element;
    const $widgetElement = $(widgetElement);

    this._widget = widgetObj.widget;
    this._inner = widgetObj.inner;

    this.element = widgetElement;
    this.header = $widgetElement.find('.hd')[0];
    this.body = $widgetElement.find('.bd')[0];
    this.footer = $widgetElement.find('.ft')[0];

    if (!config.modal && config.zIndex) {
      this.element.style.zIndex = config.zIndex;
    }

    if (this._inner.id) {
      this.element.id = `${this._inner.id}_c`;
    }

    // if header is not set, then add an empty header
    if (!this.header) {
      this.setHeader(config.title ? config.title : '');
    }

    if (config.overlayClass) {
      $(this.element).addClass(config.overlayClass);
    }

    if (config.arrow) {
      $(this.element).addClass(`arrow arrow${config.arrow}`);
    }

    if (config.tooltip) {
      $(this.element).addClass('tooltip');
    }

    if (config.close) {
      $(this.element)
        .find('.container-close')
        .on(
          'click',
          {
            panel: this,
          },
          (ev) => {
            ev.preventDefault();
            ev.data.panel.hide();
          },
        );
    }

    if (config.modalPage) {
      // these actions must be done AFTER creating the widget
      $(this.element).addClass('bl_modalPage');
    }

    //* ------------------------
    // events
    // ------------------------ */
    $widgetElement.on('open dialogopen', () => {
      $this.trigger(OPEN_EVENT);
    });

    $widgetElement.on('close dialogclose', () => {
      $this.trigger(CLOSE_EVENT);
    });
  };

  // defaults
  Panel.prototype = {
    element: null,
    header: null,
    body: null,
    footer: null,
    _widget: null,
  };

  Panel.prototype._option = function (...args) {
    return this._widget.option(...args);
  };

  // ###Method - panelObj.render(appendToNode) public method to render a panel
  // Render the ui dialog panel html in the given place
  //
  // > parameters
  // >
  // + *appendToNode* {String or Object} - The String representing the selector which the panel will be appended to.
  // Can be anything a jquery selector accepts, such as #id, .class or even a JS object, such as document.body.
  // If the string is not a selector, will test it as an ID name and if all fails, use body as default
  //
  Panel.prototype.render = function (appendToNode) {
    const show = this._widget.isOpen();
    const $renderPlace = _getRender(appendToNode);

    if (show) {
      this.hide();
    }

    this._option('appendTo', $renderPlace);

    if (show) {
      this.show();
    }

    this._rendered = true;

    return this._rendered;
  };

  Panel.prototype.setBody = function (bodyHtml) {
    if (!this.body) {
      const div = document.createElement('div');
      div.className = 'bd';
      if (this.footer) {
        this._inner.insertBefore(div, this.footer);
      } else {
        this._inner.appendChild(div);
      }

      this.body = div;
    }
    $(this.body).html(bodyHtml);
  };

  Panel.prototype.setHeader = function (headerHtml) {
    if (!this.header) {
      const div = document.createElement('div');
      const firstChild = this._inner.firstChild;
      div.className = 'hd';
      if (firstChild) {
        this._inner.insertBefore(div, firstChild);
      } else {
        this._inner.appendChild(div);
      }

      this.header = div;
    }
    $(this.header).html(headerHtml);
    if (headerHtml !== '') {
      $(this.header).show();
    } else {
      $(this.header).hide();
    }
  };

  Panel.prototype.setFooter = function (footerHtml) {
    if (!this.footer) {
      const footerElement = document.createElement('div');
      footerElement.className = 'ft';
      this._inner.appendChild(footerElement);

      this.footer = footerElement;
    }
    $(this.footer).html(footerHtml);
  };

  Panel.prototype.show = function () {
    const fixedcenter = this._option('fixedcenter');
    // const tooltip = this._option('tooltip');
    const closeOnClick = this._option('closeOnClick');
    const closeOnScroll = this._option('closeOnScroll');
    const preventClickOutsideWhileOpen = this._option('preventClickOutsideWhileOpen');

    $(this).trigger('beforeOpen');

    this._widget.open();

    if (fixedcenter) {
      this.center();

      try {
        // eslint-disable-next-line no-undef
        if (Modernizr.touch) {
          $(this.element)
            .off('focus', 'input', enableDisableAutoCentering)
            .on(
              'focus',
              'input',
              {
                panel: this,
                enableFixedCenter: false,
              },
              enableDisableAutoCentering,
            );
          $(this.element)
            .off('blur', 'input', enableDisableAutoCentering)
            .on(
              'blur',
              'input',
              {
                panel: this,
                enableFixedCenter: true,
              },
              enableDisableAutoCentering,
            );
        }
      } catch (exception) {
        // Nothing to do here but jshint requires catch block
      }

      enableDisableAutoCentering({
        data: {
          panel: this,
          enableFixedCenter: true,
        },
      });
    }

    if (closeOnClick) {
      // listener on document, IE does not bubble up click event until window
      $(document)
        .off(`click.autoClosePanel.${this._inner.id}`)
        .on(
          `click.autoClosePanel.${this._inner.id}`,
          {
            panel: this,
          },
          (event) => {
            // If that condition is met, the listener is removed and the tooltip is closed
            if (isEventOutsideOfPanel(event)) {
              if (preventClickOutsideWhileOpen) {
                event.preventDefault();
              }
              event.data.panel.hide();
            }
          },
        );
    }

    if (closeOnScroll) {
      // IE does not bubble up click event until window
      $(document)
        .off(`scroll.autoClosePanel.${this._inner.id}`)
        .on(
          `scroll.autoClosePanel.${this._inner.id}`,
          {
            panel: this,
          },
          (event) => {
            if (isEventOutsideOfPanel(event)) {
              // Listener is removed and tooltip is closed
              event.data.panel.hide();
            }
          },
        );
    }
  };

  Panel.prototype.hide = function () {
    const fixedcenter = this._option('fixedcenter');
    const closeOnClick = this._option('closeOnClick');
    const closeOnScroll = this._option('closeOnScroll');
    // const modalPage = this._option('modalPage');
    const elementId = this.element.id;
    const autoCenterEvents = _getAutoCenterEvents(elementId);

    $(this).trigger('beforeClose');

    if (fixedcenter) {
      $(window).off(autoCenterEvents);
    }

    if (closeOnClick) {
      $(document).off(`click.autoClosePanel.${this._inner.id}`);
    }

    if (closeOnScroll) {
      $(document).off(`scroll.autoClosePanel.${this._inner.id}`);
    }

    this._widget.close();
  };

  Panel.prototype.toggle = function () {
    if (this._widget && this._widget.isOpen()) {
      this.hide();
    } else {
      this.show();
    }
  };

  Panel.prototype.center = function () {
    const $element = $(this.element);
    let topPosition;
    let leftPosition;
    let topReference;

    // Due to differences between viewport size and window size.
    // Ex: iPad, because some components are breaking the responsive layout(Headers, Main Container and Body)
    if ($('body').outerWidth() >= $('html').outerWidth() || window.innerWidth >= window.outerWidth) {
      topReference = (window.innerHeight - $element.outerHeight()) / 2;
      topPosition = (topReference <= 0 ? 0 : topReference) + $(window).scrollTop();
      leftPosition = (window.innerWidth - $element.outerWidth()) / (2 + $(window).scrollLeft());
      $element.css({
        top: topPosition,
        left: leftPosition,
        position: 'absolute',
      });
    } else {
      this._option('position', {
        my: 'center',
        at: 'center',
        of: window,
        collision: 'fit',
      });
    }
  };

  Panel.prototype.unbind = function (eventType) {
    const $this = $(this.element);
    if (eventType) {
      $this.unbind(eventType);
    } else {
      $this.unbind();
    }
    return $this;
  };

  Panel.prototype.destroy = function () {
    this.hide();
    this.unbind();
    this._widget.destroy();
    $(this._inner).remove();
    this._inner = null;
    this.element = null;
  };

  // ###Method - Panel.create(panelContainer, panelConfig) public method to create a panel
  // Panel will have some methods after bein created, such as render, center, align
  //
  // > parameters
  // >
  // + *panelContainer* {String} - id name of the div who contains the panel html
  //
  // + *panelConfig* {Object} - contains the configuration for the Panel
  //
  // > returns
  // >
  // + A reference to your Panel, with element, _inner, header, footer, body
  Panel.create = function (pContainer, pConfig) {
    const panelContainer = _getContainer(pContainer);
    const panelConfig = _getMergedConfiguration(pConfig);

    const panel = new Panel(panelContainer, panelConfig);
    return panel;
  };

  module.exports = Panel;
}
