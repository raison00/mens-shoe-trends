{
  const Handlebars = require('handlebars');
  const scopes = {
    defaultScope: {},
  };

  // Utility method
  function callOtherHelper(name, args) {
    const helper = Handlebars.helpers[name];

    if (!helper) {
      throw new Error(`Helper '${name}' not found.`);
    }

    return helper.apply(this, args);
  }

  // ### Returns the errors associated with a field path on the actual context.
  //
  // This is a utility method for helpers and should NOT be called directly
  function getFieldErrors(path, options) {
    const errors = options.data.errors || {};
    let message;
    const fieldPrefix = options.data.modelAttribute ? `${options.data.modelAttribute}.` : '';
    const realPath = fieldPrefix + path;
    let index;

    if (!errors.errorsHash) {
      // initialize the short cut errors map
      errors.errorsHash = {};

      if (errors.fieldMessages) {
        for (index = 0; index < errors.fieldMessages.length; index++) {
          message = errors.fieldMessages[index];
          errors.errorsHash[message.fieldName] = message;
        }
      }
    }

    return errors.errorsHash[realPath];
  }

  // key can be of type x or x[ 2 ] or x [ "y" ]. Should NOT have any '.' in the key
  function getValue(k, json) {
    let key = k;
    if (!key || key.indexOf('.') !== -1) {
      throw new Error(`Invalid key ${key}`);
    }

    if (!json) {
      return undefined;
    }

    const reg = /([^[]*)\[([^\]]*)\s*\]/;
    const match = reg.exec(key);
    let index;
    let value;

    if (match) {
      key = match[1];
      index = match[2].trim();
    }

    value = json[key];

    if (value && index !== undefined) {
      value = value[index];
    }

    return value;
  }

  function getValueFromJSON(key, json) {
    if (!key || !json) {
      return undefined;
    }

    const parts = key.split('.');
    let part;
    let i = 0;
    const l = parts.length;
    let context = json;

    for (; i < l; i++) {
      part = parts[i];
      context = getValue(part, context);
    }

    return context;
  }

  // options could be either Handlebars options or scope String
  function set(key, value, opts) {
    let options = opts;
    let hash;
    let data;
    let scope;
    let scopeObj;

    if (options && typeof options === 'string') {
      scope = options;
      data = {};
    } else {
      options = options || {};

      hash = options.hash || {};
      data = options.data || {};
      scope = hash.scope;
    }

    // If scope is provided use it otherwise use following logic
    if (!scope) {
      // if templateScope is available use it
      if (data.templateScope) {
        scopeObj = data.templateScope;
      } else {
        scope = 'defaultScope';
      }
    }

    if (!scopeObj) {
      scopeObj = scopes[scope] || (scopes[scope] = {});
    }

    scopeObj[key] = value;
  }

  function get(key, options = {}) {
    if (!key) {
      return undefined;
    }

    const data = options.data || {};
    let parts;
    let scope;

    if (key.indexOf('.') !== -1) {
      parts = key.split('.');
      scope = scopes[parts[0]];

      return scope ? scope[parts[1]] : undefined;
    }

    return data.templateScope ? data.templateScope[key] : scopes.defaultScope[key];
  }

  // parse values from path strings to create valid ids.
  function getIdFromPath(path) {
    return path.replace(/\[\s*|\s*\]/g, '');
  }

  // either 'str' or 10 like strings will return true
  function isPrimitive(val) {
    let retValue;

    if (Number.isNaN(Number(val))) {
      // Not a Number, check for pattern like "something"
      retValue = /^(['"]).*\1$/.test(val);
    } else {
      // Number
      retValue = true;
    }

    return retValue;
  }

  // Assumption str will pass isPrimitive test
  function getPrimitiveValue(s) {
    let str = s;
    if (/^(['"]).*\1$/.test(str)) {
      // convert '0' => String 0
      str = str.replace(/^(['"])(.*)\1$/, '$2');
    } else {
      // 0 => Number(0)
      str = Number(str);
    }

    return str;
  }

  function getContextValue(expression, context = {}, options = {}) {
    let exp = expression;
    if (exp.indexOf('.') === -1) {
      // private variable
      if (exp.indexOf('@') === 0) {
        return options.data ? options.data[exp.substr(1)] : undefined;
      } else if (exp === 'this') {
        // keyword 'this'
        return context;
      }
      // [x] => x
      exp = exp.replace(/^\[(.+)\]$/, '$1').trim();
      return context[exp];
    }
    const parts = exp.split('.');
    let i = 0;
    const l = parts.length;
    let retValue = context;
    for (; i < l; i++) {
      retValue = getContextValue(parts[i], retValue);

      if (!retValue) {
        break;
      }
    }

    return retValue;
  }

  function parse(s, sections = [], strings = []) {
    // skip corresponding \' and \"
    const stringRegex = /(?:'(?:[^'\\]|\\')*')|(?:"(?:[^"\\]|\\")*")/;
    const sectionRegex = /\([^)(]*\)/;
    let match;
    const tree = {};
    const refill = function (t) {
      const text = t.replace(/---(\d+)---/, (m, p1) => sections[p1]).replace(/%%%(\d+)%%%/g, (m, p1) => strings[p1]);
      return text;
    };

    let str = s.trim();
    // change " ( a < b ) " to "a < b"
    if (str.match(/^\([^)(]+\)$/)) {
      str = str.replace(/^\((.*)\)$/, '$1').trim();
    }

    // eslint-disable-next-line no-cond-assign
    while ((match = stringRegex.exec(str)) !== null) {
      str = str.replace(stringRegex, `%%%${strings.length}%%%`);
      strings.push(match[0]);
    }

    // strings have been replaced, so no confusion of '(' or ')' inside strings
    while ((match = sectionRegex.exec(str)) !== null) { // eslint-disable-line no-cond-assign
      str = str.replace(sectionRegex, `---${sections.length}---`);
      sections.push(match[0]);
    }

    const parts = str.split(/\s+/);
    if (parts.length !== 1 && parts.length !== 3) {
      // eslint-disable-line no-cond-assign
      throw new Error(`invalid number of arguments ${parts}`);
    }

    // TODO: can we refill what ever is necessary NOT every thing
    tree.arg1 = refill(parts[0]);
    if (parts.length > 1) {
      // Need the previous sections, so pass the previous sections to parse
      tree.arg1 = parse(tree.arg1, sections, strings);
      tree.operator = parts[1];

      // Need the previous sections, so pass the previous sections to parse
      tree.arg2 = parse(refill(parts[2]), sections, strings);
    }

    return tree;
  }

  function calculate(arg1, operator, arg2) {
    /* jshint eqeqeq: false */
    // in handlebars {{this}} could be a Number or String, so we need to provide == and !=

    switch (operator) {
      case '||':
        return arg1 || arg2;
      case '&&':
        return arg1 && arg2;
      case '==':
        return arg1 == arg2; // eslint-disable-line eqeqeq
      case '===':
        return arg1 === arg2;
      case '!=':
        return arg1 != arg2; // eslint-disable-line eqeqeq
      case '!==':
        return arg1 !== arg2;
      case '<':
        return arg1 < arg2;
      case '<=':
        return arg1 <= arg2;
      case '>':
        return arg1 > arg2;
      case '>=':
        return arg1 >= arg2;
      case '%':
        return arg1 % arg2;
      case '+':
        return arg1 + arg2;
      case '-':
        return arg1 - arg2;
      case '/':
        return arg1 / arg2;
      case '*':
        return arg1 * arg2;
      default:
        throw new Error(`Operator '${operator}' is not implemented.`);
    }
  }

  function processTree(tree, context, options) {
    const operator = tree.operator;
    let exp;

    if (!operator) {
      exp = tree.arg1;

      switch (exp) {
        case 'true':
        case true:
          return true;

        case 'false':
        case false:
          return false;

        case 'undefined':
        case undefined:
          return undefined;

        case 'null':
        case null:
          return null;

        default:
          // exp will always be of type string
          // either 'str' or 10 or x.y.[5] etc.
          // in above example 'str' and 10 will be considered primitive, string and number respectively
          if (isPrimitive(exp)) {
            return getPrimitiveValue(exp);
          } else if (typeof exp === 'string' && exp.indexOf('$') === 0) {
            // Assume $test is a variable that was saved with {{set}} helper
            return get(exp.substr(1), options);
          }
          return getContextValue(exp, context, options);
      }
    }

    const arg1 = processTree(tree.arg1, context, options);
    const arg2 = processTree(tree.arg2, context, options);

    // TODO: work on short circuit
    return calculate(arg1, operator, arg2);
  }

  // ### Returns a string with all attributes to be used by the helpers
  // ## Example using:
  //    joinAttributes(attrs)
  function joinAttributes(attrs) {
    let attrsString = '';

    Object.keys(attrs).forEach((key) => {
      if (Object.prototype.hasOwnProperty.call(attrs, key)) {
        attrsString += `${key}="${attrs[key]}" `;
      }
    });

    // ensuring space before/after just in case someone call it without adding the spaces
    return ` ${attrsString}`;
  }

  module.exports = {
    // #### evaluate - a utility method primary used by {{condition}} helper. See Helpers' condition helper for more details of this method
    // >Note: the expression shall not have a couple of outer parenthesis, like '(a && b)', it has to be 'a && b'.
    // >Inner parenthesis are allowed, like 'a && (b || c)
    //
    // options is handlebars options
    // $scope.key is assumed to be a var "key" set in the specified scope
    evaluate(expression, context, options) {
      return processTree(parse(expression), context, options);
    },

    get,
    set,

    getValueFromJSON,
    callOtherHelper,

    getIdFromPath,

    getFieldErrors,

    joinAttributes,
  };
}
