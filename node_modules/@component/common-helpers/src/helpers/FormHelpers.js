const $ = require('jquery');
const Handlebars = require('handlebars');
const CommonUtils = require('./Utils');

const MODEL_ATTRIBUTE = 'modelAttribute';
const escapeExpression = Handlebars.Utils.escapeExpression;

// ### Check whenever a path has an associated error on the
//    actual context.
function hasError(path, options) {
  return CommonUtils.getFieldErrors(path, options) !== undefined;
}
// ### Process classes for the helpers
//    like (invalid, class, errorClass and cssClass).
//    The result will be available on the attrs array passed to the method.
//
// ## Example using:
//    processClass.call(this, attrs, options)
function processClass(attrs, opts) {
  const options = opts;
  let path = '';
  let defaultClasses;
  let errorClasses;
  let cssClasses;
  let isInvalid = false;
  let value;
  let valueEscaped;
  const classes = [];

  Object.keys(options.hash).forEach((key) => {
    value = options.hash[key];
    valueEscaped = escapeExpression(value);

    switch (key) {
      case 'path':
        path = valueEscaped;

        break;

      case 'errorClass':
        errorClasses = valueEscaped;

        delete options.hash.errorClass;
        break;

      case 'cssClass':
        cssClasses = valueEscaped;

        delete options.hash.cssClass;
        break;

      case 'class':
        defaultClasses = valueEscaped;

        delete options.hash.class;
        break;

      case 'invalid':
        isInvalid = valueEscaped === true || valueEscaped === 'true';

        break;
      default:
        break;
    }
  });

  classes.push(defaultClasses);
  if (hasError.call(this, path, options) || isInvalid) {
    classes.push(errorClasses);

    options.hash.invalid = true;
  } else {
    classes.push(cssClasses);
  }

  attrs.push(`class="${classes.join(' ').trim()}"`);
}

function getHiddenField(name, value) {
  return `<input type="hidden" name="${name}" value="${value}" />`;
}

// ### Process common attributes for the helpers
//    like (id and disabled).
//    The result will be available on the attrs array passed to the method.
//
// ## Example using:
//    processCommon.call(this, attrs, options)
function processCommon(attrs, opts) {
  const options = opts;
  let path;
  let id;
  let value;
  let valueEscaped;
  let isDisabled = false;
  let isInvalid = false;

  // process classes for the component helper
  processClass.call(this, attrs, options);
  Object.keys(options.hash).forEach((key) => {
    value = options.hash[key];
    valueEscaped = escapeExpression(value);

    switch (key) {
      case 'path':
        path = valueEscaped;
        break;

      case 'id':
        id = valueEscaped;

        delete options.hash.id;
        break;

      case 'disabled':
        isDisabled = valueEscaped;

        delete options.hash.disabled;
        break;

      case 'invalid':
        isInvalid = valueEscaped;

        delete options.hash.invalid;
        break;

      case 'name':
        delete options.hash.name;
        break;
      default:
        break;
    }
  });

  if (!path || !path.trim()) {
    throw new Error("Required attribue 'path' is missing.");
  }

  // process id and name
  attrs.push(`id="${id || CommonUtils.getIdFromPath(path)}"`);

  attrs.push(`name="${path}"`);

  if (isDisabled === true || isDisabled === 'true') {
    attrs.push('disabled="disabled"');
    attrs.push('aria-disabled="true"');
  }

  if (isInvalid === true || isInvalid === 'true') {
    attrs.push('aria-invalid="true"');
  }
}

// ### Example usage:
//    {{#ifErrors "x.y.z"}}Error Render{{else}}Normal Render{{/ifErrors}}
Handlebars.registerHelper('ifErrors', function (path, options) {
  const errorFound = hasError.call(this, path, options);

  return CommonUtils.callOtherHelper.call(this, 'if', [errorFound, options]);
});

Handlebars.registerHelper('form', function (opts) {
  const options = opts;
  let html = '<form ';
  let value;
  let valueEscaped;
  const attrs = [];
  let data;

  if (options.data) {
    data = Handlebars.createFrame(options.data);
  }

  Object.keys(options.hash).forEach((key) => {
    value = options.hash[key];
    valueEscaped = escapeExpression(value);
    if (key === MODEL_ATTRIBUTE) {
      if (data) {
        data[MODEL_ATTRIBUTE] = valueEscaped;
      }
    } else {
      attrs.push(`${key}='${valueEscaped}'`);
    }
  });

  html += `${attrs.join(' ')}>${options.fn(this, {
    data,
  })}</form>`;

  return html;
});

// ### Example usage:
//      {{label path="x.y" value="..." [for="..."] [id="..."] [any free attribute] [cssClass="..."] [errorClass="..."]}}
//    or
//    {{#label path="x.y" [for="..."] [id="..."] [any free attribute] [cssClass="..."] [errorClass="..."]}} Label text here {{/label}}
//
//    renders:
//      <label for="<path|for>" id="<id>"  ... >value</label>
//
//    where:
//      path: mandatory path to the context value [required]
//      value:
//      for: custom for attribute with precedence.
//      id: custom id with precedence.
//
Handlebars.registerHelper('label', function (opts) {
  const options = opts;
  let labelStart = '<label ';
  const labelEnd = '</label>';
  let dataPath = '';
  let labelFor = '';
  let labelValue = '';
  let value;
  let valueEscaped;
  const attrs = [];
  let isBlockHelper = false;

  if (options.fn) {
    // helper was used as block helper
    // pull the textValue from body
    labelValue = options.fn(this);
    isBlockHelper = true;
  }

  // process class attributes
  processClass.call(this, attrs, options);

  // process known attributes
  Object.keys(options.hash).forEach((key) => {
    value = options.hash[key];
    valueEscaped = escapeExpression(value);

    switch (key) {
      case 'path':
        dataPath = valueEscaped;
        break;

      case 'for':
        labelFor = valueEscaped;
        break;

      case 'value':
        labelValue = CommonUtils.callOtherHelper.call(this, 'i18n', [
          value,
          {
            data: options.data,
          },
        ]);
        break;

      case 'invalid':
        break;

      default:
        // free attributes added to the helper
        attrs.push(`${key}="${valueEscaped}"`);
    }
  });

  if (!labelValue.trim()) {
    throw new Error("Required attribute 'value' is missing.");
  }

  if (!dataPath.trim()) {
    throw new Error("Required attribue 'path' is missing.");
  }

  // process custom for
  attrs.push(`for="${labelFor || CommonUtils.getIdFromPath(dataPath)}"`);

  // complete the tag format
  labelStart += `${attrs.join(' ')}>${labelValue}${labelEnd}`;

  return isBlockHelper ? labelStart : new Handlebars.SafeString(labelStart);
});

// ### Example usage:
//      {{input path="x.y" [id="..."] [any free attribute]}}
//
//    renders:
//      <input type="text" name="<path>" id="<path|id>" value="<context.x.y>" ... />
//
//    where:
//      path: mandatory path to the context value [required]
//      id: custom id with precedence.
//
Handlebars.registerHelper('input', function (opts) {
  const options = opts;
  let inputText = '<input ';
  let dataPath = '';
  let inputValue = '';
  let inputType = '';
  let value;
  let valueEscaped;
  const attrs = [];

  // process common attributes for components
  processCommon.call(this, attrs, options);

  // process known attributes
  Object.keys(options.hash).forEach((key) => {
    value = options.hash[key];
    valueEscaped = escapeExpression(value);

    switch (key) {
      case 'path':
        dataPath = valueEscaped;
        inputValue = escapeExpression(CommonUtils.getValueFromJSON(dataPath, this));

        if (inputValue === undefined) {
          inputValue = '';
        }

        break;

      case 'type':
        inputType = valueEscaped;
        break;

      case 'value':
        break;

      default:
        // free attributes added to the helper
        attrs.push(`${key}="${valueEscaped}"`);
    }
  });

  attrs.push(`value="${inputValue}"`);
  attrs.push(`type="${inputType.trim() ? inputType : 'text'}"`);

  // complete the tag format
  inputText += `${attrs.join(' ')}/>`;

  return new Handlebars.SafeString(inputText);
});

// ### Example usage:
//      {{checkbox path="x.y" [id="..."] [any free attribute]}}
//
//    renders:
//      <input type="checkbox" name="<path>" id="<path|id>" ... />
//
//    where:
//      path: mandatory path to the context value [required]
//      id: custom id with precedence.
//
Handlebars.registerHelper('checkbox', function (opts) {
  const options = opts;
  let inputText = '<input type="checkbox" ';
  let inputValue = 'on';
  let dataPath = '';
  let checked = '';
  let inputId = '';
  let value;
  let valueEscaped;
  const attrs = [];

  // process common attributes for components
  processCommon.call(this, attrs, options);

  // process known attributes
  Object.keys(options.hash).forEach((key) => {
    value = options.hash[key];
    valueEscaped = escapeExpression(value);

    switch (key) {
      case 'path':
        dataPath = value;
        checked = CommonUtils.getValueFromJSON(dataPath, this);

        if (checked === undefined) {
          checked = false;
        }

        break;

      case 'id':
        inputId = valueEscaped;
        break;

      case 'type':
        break;

      case 'value':
        inputValue = valueEscaped;
        attrs.push(`value="${valueEscaped}"`);
        break;

      default:
        // free attributes added to the helper
        attrs.push(`${key}="${valueEscaped}"`);
    }
  });

  if (!dataPath) {
    throw new Error("Required attribute 'path' is missing.");
  }

  // process default name, id and value
  dataPath = CommonUtils.getIdFromPath(dataPath);

  attrs.push(`id="${inputId || dataPath}"`);
  attrs.push(`name="${dataPath}"`);

  if (checked) {
    attrs.push('checked="checked"');
  }

  // complete the tag format and create a hidden field
  inputText += `${attrs.join(' ')}/>${getHiddenField(`_${dataPath}`, inputValue)}`;

  return new Handlebars.SafeString(inputText);
});

// ### Example usage:
//      {{radiobutton path="x.y" value="..." [id="..."] [any free attribute]}}
//
//    renders:
//      <input type="radio" value="..." name="<path>" id="<path|id>" ... />
//
//    where:
//      path: mandatory path to the context value [required]
//      value: mandatory value of the button [required]
//      id: custom id with precedence.
//
Handlebars.registerHelper('radiobutton', function (opts) {
  const options = opts;
  let inputText = '<input type="radio"';
  let dataPath = '';
  let contextValue;
  let inputValue = '';
  let checked = false;
  let value;
  let valueEscaped;
  const attrs = [];

  // process common attributes for components
  processCommon.call(this, attrs, options);

  // process known attributes
  Object.keys(options.hash).forEach((key) => {
    value = options.hash[key];
    valueEscaped = escapeExpression(value);

    switch (key) {
      case 'path':
        dataPath = value;
        contextValue = CommonUtils.getValueFromJSON(dataPath, this);

        if (contextValue === undefined) {
          contextValue = '';
        }

        break;

      case 'value':
        inputValue = valueEscaped;
        break;

      case 'type':
        break;

      default:
        // free attributes added to the helper
        attrs.push(`${key}="${valueEscaped}"`);
    }
  });

  if (!inputValue) {
    throw new Error("Required attribue 'value' is missing.");
  }

  if (!dataPath) {
    throw new Error("Required attribute 'path' is missing.");
  }

  // process value
  if (inputValue === contextValue) {
    checked = true;
  }

  attrs.push(`value="${inputValue}"`);

  if (checked) {
    attrs.push(' checked="checked"');
  }

  // complete the tag format
  inputText += `${attrs.join(' ')}/>`;

  return new Handlebars.SafeString(inputText);
});

// ### Example usage:
//      {{#select path="x.y" [id="..."] [any free attribute]}} {{/select}}
//
//    renders:
//      <select name="<path>" id="<path|id>" ... ></select>
//
//    where:
//      path: mandatory path to the context value
//
Handlebars.registerHelper('select', function (opts) {
  const options = opts;
  let html = '<select ';
  let data;
  let path;
  let value;
  let valueEscaped;
  const attrs = [];

  // process common attributes for components
  processCommon.call(this, attrs, options);

  Object.keys(options.hash).forEach((key) => {
    value = options.hash[key];
    valueEscaped = escapeExpression(value);

    switch (key) {
      case 'path':
        path = valueEscaped;
        break;

      case 'value':
        // ignore name and value
        break;

      default:
        attrs.push(`${key}='${valueEscaped}'`);
        break;
    }
  });

  if (!path) {
    throw new Error("Required attribute 'path' is missing");
  }

  if (options.data) {
    data = Handlebars.createFrame(options.data);

    // add current context private variable @i18n
    data.selectedOptionValue = CommonUtils.getValueFromJSON(path, this);
  }

  html += `${attrs.join(' ')}>${options.fn(this, {
    data,
  })}</select>`;

  return html;
});

// ### Example usage:
//      {{options keys="array | map"}} - keys is required
//            pass keys="$scope.key" to pull the saved key
//
//    renders:
//      <option> tags and select the proper <option> based on the value of parent {{#select}}
//
//
Handlebars.registerHelper('options', function (options) {
  let html = '';
  let keys = options.hash.keys;
  let optionValue;
  let optionText;
  const data = options.data || {};
  const originalKeys = keys;
  const selectedValue = data.selectedOptionValue;

  if (typeof keys === 'string' && keys.indexOf('$') === 0) {
    keys = CommonUtils.callOtherHelper.call(this, 'get', [keys.substr(1)]);
  }

  if (!keys) {
    throw new Error(`Required attribute 'keys' is missing. You passed: ${originalKeys}`);
  }

  const isArray = $.isArray(keys);

  // > keys could be array, Object or sortedMap
  // >
  // ["Jan", "Feb"] - Array
  // or {"01": "Jan", "02": "Feb"} - Object
  // or [{"key": "01", "value": "Jan"}, {"key": "02", "value": "Feb"}] - a sortedMap
  $.each(keys, (key, value) => {
    if (keys && keys.isSortedMap) {
      optionValue = value.key;
      optionText = value.value;
    } else {
      optionValue = isArray ? value : key;
      optionText = value;
    }

    /*
             * Type equalization
             */
    if (selectedValue) {
      if (typeof selectedValue === 'string') {
        optionValue = String(optionValue);
      } else if (typeof selectedValue === 'number') {
        optionValue = Number(optionValue);
      }
    }

    html += `<option${optionValue ? ` value='${escapeExpression(optionValue)}'` : ''}${
      selectedValue && selectedValue === optionValue ? " selected='selected'" : ''
    }>${escapeExpression(optionText)}</option>`;
  });

  return new Handlebars.SafeString(html);
});
