// ###Helper forEach
//
// Replacement for the existing Handlebars each helper.  Adds support for begin, end(inclusive), and step parameters
// Also allows for not passing an array so it will work like a while loop
//
// @param {array|object} items   Items/object to loop over
// @param {Integer} begin         Index to start the loop
// @param {Integer} end           Index to stop the loop.  End is inclusive
// @param {Integer} step          Interval to iterate the list with
//
// Function will loop over the object or array from 0 until the end of the list/object keys
// If items is not specified the loop will execute the specified number of times(from begin to end)
// If begin is specified it will start at that index
// If end is specified it will end at that index including the item there.  End will be the length of the list if not
// specified or greater than the length
// Step will default to 1 and must be greater than 0
//
//
// Available private variables
//  @index - The index of the loop.  Index is 0 based
//  @count - The number of times the loop has executed.  Count is 1 based
//  @first - boolean true if this is the first run for the loop
//  @last - boolean true if this is the last run for the loop
//  @key - used only when iterating objects.  Provides the key where the current value was found
//
// #### Example usage:
//      Given someArray = [ {name: "Mike"}, {name: "Tim"}, {name: "Diego"}, {name: "Hannah"}, {name: "Liz"}, {name: "Dennis"} ]
//      {{#forEach items=someArray| begin=0 end=10 step=2}}<div>{{name}}</div>{{/forEach}}
//      Output: <div>Mike</div><div>Diego</div><div>Liz</div>
//
//      Given someObject = { name: "Mike", age: 30, city: "New York", country: "USA",  }
//      {{#forEach items=someObject}}<div>{{@key}} = {{this}}</div>{{/forEach}}
//      Output: <div>name = Mike</div><div>age = 30</div><div>city = New York</div><div>country = USA</div>
//
//      {{#forEach begin=1 end=7}}<li>{{this}}</li>{{/forEach}}
//      Output: <li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li>

module.exports = function (options) {
  // demonstrating commonJS code that runs on both server/client
  const Handlebars = require('handlebars/runtime');
  const Logger = require('@core/util/clientlogger');

  const hash = options.hash || {};
  const items = hash.items;
  let begin = hash.begin || 0;
  let end;
  let step = hash.step || 1;
  let data;
  let i;
  let count = 1;
  let keys;
  let key;
  let output = '';
  const types = {
    ARRAY: 'array',
    MAP: 'map',
    LOOP: 'loop',
  };
  let type;

  function setData() {
    if (data) {
      const nextIndex = i + step;
      data.index = i;
      data.count = count;
      data.first = i === begin;
      data.last = nextIndex > end;
      if (key) {
        data.key = key;
      }
    }
  }

  function getContext() {
    let context;
    if (type === types.LOOP) {
      context = i;
    } else if (type === types.ARRAY) {
      context = items[i];
    } else if (type === types.MAP) {
      context = items[keys[i]];
    }
    return context;
  }

  function updateEnd(list) {
    end = hash.end || list.length;
    if (end > list.length - 1) {
      end = list.length - 1;
    }
  }

  if (options.data) {
    data = Handlebars.createFrame(options.data);
  }

  try {
    if (items && typeof items === 'object') {
      if (Array.isArray(items)) {
        updateEnd(items);
        type = types.ARRAY;
      } else {
        keys = Object.keys(items);
        updateEnd(keys);
        type = types.MAP;
      }
    } else {
      end = hash.end || 0;
      type = types.LOOP;
    }
  } catch (err) {
    Logger.error('Caught exception in forEach helper: ', err);
    return '';
  }

  // Make sure these are actually numbers
  begin = parseInt(begin, 10);
  end = parseInt(end, 10);
  step = parseInt(step, 10);

  // Error checking.  Begin, end, step must be integers and begin must be less than end
  if (Number.isNaN(Number(begin))) {
    throw new Error('begin must be an integer');
  }
  if (Number.isNaN(Number(end))) {
    throw new Error('end must be an integer');
  }
  if (Number.isNaN(Number(step))) {
    throw new Error('step must be an integer');
  }
  if (begin < 0) {
    throw new Error('begin must be 0 or greater');
  }
  if (step < 0) {
    throw new Error('step must be a positive integer');
  }

  for (i = begin; i <= end; i += step, count++) {
    if (type === types.MAP) {
      key = keys[i];
    }
    setData();
    output += options.fn(getContext(), {
      data,
    });
  }

  // If the loop does not execute then do the else path
  if (i === begin) {
    output = options.inverse(this);
  }

  return output;
};
