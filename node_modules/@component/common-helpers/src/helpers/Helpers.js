{
  const Handlebars = require('handlebars');
  const Utils = require('./Utils');
  const MathUtil = require('@core/util/mathutil');
  const Globals = require('@core/util/globals');
  const Logger = require('@core/util/clientlogger');

  const IF = 'if';
  const escapeExpression = Handlebars.Utils.escapeExpression;

  // #### Example usage:
  //      {{#condition "<value1> <operator> <value2>"}}
  //      <content>
  //    [ {{else}} <else content> ]
  //    {{/condition}}
  //
  //  Assumptions: operators are separated by spaces
  //    (x === '1' || x === '2') is not supported
  //    use
  //    (x === '1') || (x === '2')
  //    ($scope.key === 'value') - (NOTE: no quotes around $scope.key) $scope.key will pull the value of key
  //    from the scope using Utils.get("scope.key", options)
  //    Multiple expressions are allowed, just need to separate each within parenthesis:
  //    a === true && b === 'abc' || c === 'def' && d === false is not supported
  //    (a === true) && ((b === 'abc') || ((c === 'def') && (d === false))) is supported
  //    flagA && (flagB || (flagC && flagD)) is supported. (Same as above but easier to read :D )
  //    Outer parenthesis are NOT supported
  //    (flagA && flagB) is not supported
  //    flagA && flagB is supported
  //  Usable values:
  //    Handlebars variables with @ - Example: @index, @key, @first, @last
  //    this - Handlebars current context
  //    Scope variables created with set helper - Example $scope.key
  //  Available operators
  //    || - Logical OR
  //    && - Logical AND
  //    ===, !== - Identity comparison(no type conversion)
  //    ==, != - Equality comparison(type conversion)
  //    <, >, <=, >= - Relational comparison
  //    %, +, -, *, / - Mathematical operations
  Handlebars.registerHelper('condition', function (expression, options) {
    return Utils.callOtherHelper.call(this, IF, [Utils.evaluate(expression, this, options), options]);
  });

  // ### Helper {{ifFeatureEnabled}}
  //      Tests for attributes defined on the Globals.props
  //
  // #### Example usage:
  //      {{#ifFeatureEnabled "brightTagEnabled"}} enabled {{else}} not enabled {{/ifFeatureEnabled}}
  //
  //
  Handlebars.registerHelper('ifFeatureEnabled', function (featureFlag, options) {
    let enabled = false;
    let flag;

    if (typeof featureFlag === 'string') {
      flag = Globals.getValue(`props.${featureFlag}`);
      if (flag === true || (typeof flag === 'string' && flag.toLowerCase() === 'true')) {
        enabled = true;
      }
    }

    return Utils.callOtherHelper.call(this, IF, [enabled, options]);
  });

  // #### Example usage:
  //      {{formatNumber value = <value1>  pattern = <value2>}}
  //      {{formatNumber  value = 1234.678 pattern = '#,###.0'}} - will display 1,234.7
  Handlebars.registerHelper('formatNumber', options => MathUtil.formatNumber(options.hash.value, options.hash.pattern));

  // ### Helper {{set}}
  //    Pass evaluate=true to evaluate the expression before setting
  //
  // #### Example usage:
  //      {{set var="testKey" value="test value" [scope="myScope"]}}
  //      {{#set var="testKey" [scope="myScope"]}} {{get "myScope.blockKey"}} {{/set}}
  //      {{set var="evaluatedKey" value="10 % 6" evaluate=true}}
  //
  Handlebars.registerHelper('set', function (options) {
    const hash = options.hash;
    const key = hash.var;
    let value = hash.value;

    if (options.fn) {
      value = options.fn(this);
    }

    if (!key || key.indexOf('.') !== -1) {
      throw new Error(`Invalid var '${key}'`);
    }

    if (hash && (hash.evaluate === true || hash.evaluate === 'true')) {
      value = Utils.evaluate(value, options);
    }

    Utils.set(key, value, options);
  });

  // #### Example usage:
  //      {{get "testKey"}}
  //
  Handlebars.registerHelper('get', (key, options) => {
    if (typeof key !== 'string') {
      throw new Error("Required attribute 'key' is missing");
    }

    const value = Utils.get(key, options);

    if (value && typeof value === 'string') {
      return escapeExpression(value);
    }

    return value;
  });

  // ### Helper {{getGlobalValue "key"}}
  //
  // ### Example usage:
  //    {{getGlobalValue "props.domesticMode"}}
  Handlebars.registerHelper('getGlobalValue', (value) => {
    let globalValue = '';

    if (Globals && typeof value === 'string') {
      globalValue = Globals.getValue(value);
    }
    return globalValue;
  });

  Handlebars.registerHelper('toLowerCase', (value) => {
    let valueScaped;

    if (value && typeof value === 'string') {
      valueScaped = escapeExpression(value);

      return valueScaped.toLowerCase();
    }

    return '';
  });

  Handlebars.registerHelper('toUpperCase', (value) => {
    let valueScaped;

    if (value && typeof value === 'string') {
      valueScaped = escapeExpression(value);

      return valueScaped.toUpperCase();
    }

    return '';
  });

  // ### Helper baseHost
  //
  // #### Example usage:
  //    {{baseHost}}
  Handlebars.registerHelper('baseHost', () => Globals.getValue('props.baseHost'));

  // ### Helper secureHost
  //
  // #### Example usage:
  //    {{secureHost}}
  Handlebars.registerHelper('secureHost', () => Globals.getValue('props.secureHost'));

  // ### Helper assetsHost
  //
  // #### Example usage:
  //    {{assetsHost}}
  Handlebars.registerHelper('assetsHost', () => Globals.getValue('props.assetsHost'));

  // ### Helper imageHost
  //
  // #### Example usage:
  //    {{imageHost}}
  Handlebars.registerHelper('imageHost', () => Globals.getValue('props.imageHost'));

  // ### Block Helper bind
  // >Creates private variables @i18n, @templateScope and @errors
  // >
  // >To create other private variables pass them in the hash prefixed with _ (e.g. _inlineServerErrorsEnabled=true, it
  // >will create @inlineServerErrorsEnabled with value true)
  // >
  // +Default key for i18n is *i18n*. Pass i18n=yourKey to override it
  // +When using {{set}} and {{get}}, without scope, templateScope will be used as default scope
  // +If you do not want to create these variables, pass i18n=false, *scope*=false, errors=false
  // #### Example usage:
  //      {{#bind}}.....{{/bind}}
  //    {{#bind i18n=messagesKey}}.....{{/bind}}
  //    {{#bind _inlineServerErrorsEnabled=true}}.....{{/bind}}
  //    {{#bind _privateVar=keyWhereValueShouldBePulledFromTheData}}.....{{/bind}}
  Handlebars.registerHelper('bind', function (options) {
    let data;
    const hash = options.hash;
    let i18n;
    let scope;
    let errors;

    if (options.data) {
      data = Handlebars.createFrame(options.data);

      i18n = hash.i18n;
      // Allow  i18n to be overridden, so that parent and child could have different messages Object
      if (String(i18n) !== 'false') {
        // create private variable @i18n
        data.i18n = i18n || this.i18n;
      }

      scope = hash.scope;
      // if @templateScope is already present, do not override it
      if (!data.templateScope && String(scope) !== 'false') {
        // create private variable @templateScope
        data.templateScope = {};
      }

      errors = hash.scope;
      if (!data.errors && String(errors) !== 'false') {
        // create private variable @errors
        data.errors = this.errors;
      }

      // add other private variables
      Object.keys(hash).forEach((key) => {
        if (key.indexOf('_') === 0) {
          data[key.substr(1)] = hash[key];
        }
      });
    }

    return options.fn(this, {
      data,
    });
  });

  // ### Helper i18n
  //
  // Helper for internationalization. Translates a key to it's message. It also accepts parameters on the messages for
  // dynamic messages.
  //
  // Assumptions: In the messages.json, keys will NOT contain '.'
  //
  // #### Example usage:
  //    context = {
  //      messages: {
  //        "x": {y: "value of x.y"},
  //        "a.b": "this will not work"},
  //        "introduceMe": "My name is {0}.",
  //        "introduceMeBond": "My name is {1}. {0} {1}.",
  //      }
  //    }
  //
  //      {{i18n "x.y"}} - will display "value of x.y
  //    {{i18n "a.b"}} - will display "value of ???a.b???
  //    {{i18n "introduceMe" "James"}} - will display "My name is James."
  //    {{i18n "introduceMeBond" "James" "Bond"}} - will display "My name is Bond. James Bond."
  Handlebars.registerHelper('i18n', function (key, ...args) {
    const keyScaped = escapeExpression(key);
    let retValue = `???${keyScaped}???`;
    const options = args[args.length - 1];
    const hash = options.hash || {};
    let messages = this.i18n;
    let parameters = [];

    if (!messages && options.data) {
      messages = options.data.i18n;
    }

    if (messages) {
      retValue = Utils.getValueFromJSON(keyScaped, messages) || retValue;
    }

    if (arguments.length > 2) {
      // excluding first and last positions (message key and options object)
      parameters = Array.prototype.slice.call(args, 0, args.length - 1);

      retValue = retValue.replace(/{(\d)}/g, (match, p1) => parameters[p1]);
    }

    if (
      retValue &&
      ((typeof hash.escape === 'string' && hash.escape.toLowerCase() === 'false') || (typeof hash.escape === 'boolean' && !hash.escape))
    ) {
      retValue = new Handlebars.SafeString(retValue);
    }

    return retValue;
  });

  Handlebars.registerHelper('getEncodedValue', value => encodeURIComponent(value));

  // ###Helper forEach
  //
  // Replacement for the existing Handlebars each helper.  Adds support for begin, end(inclusive), and step parameters
  // Also allows for not passing an array so it will work like a while loop
  //
  // @param {array|object} items   Items/object to loop over
  // @param {Integer} begin         Index to start the loop
  // @param {Integer} end           Index to stop the loop.  End is inclusive
  // @param {Integer} step          Interval to iterate the list with
  //
  // Function will loop over the object or array from 0 until the end of the list/object keys
  // If items is not specified the loop will execute the specified number of times(from begin to end)
  // If begin is specified it will start at that index
  // If end is specified it will end at that index including the item there.  End will be the length of the list if not
  // specified or greater than the length
  // Step will default to 1 and must be greater than 0
  //
  //
  // Available private variables
  //  @index - The index of the loop.  Index is 0 based
  //  @count - The number of times the loop has executed.  Count is 1 based
  //  @first - boolean true if this is the first run for the loop
  //  @last - boolean true if this is the last run for the loop
  //  @key - used only when iterating objects.  Provides the key where the current value was found
  //
  // #### Example usage:
  //      Given someArray = [ {name: "Mike"}, {name: "Tim"}, {name: "Diego"}, {name: "Hannah"}, {name: "Liz"}, {name: "Dennis"} ]
  //      {{#forEach items=someArray| begin=0 end=10 step=2}}<div>{{name}}</div>{{/forEach}}
  //      Output: <div>Mike</div><div>Diego</div><div>Liz</div>
  //
  //      Given someObject = { name: "Mike", age: 30, city: "New York", country: "USA",  }
  //      {{#forEach items=someObject}}<div>{{@key}} = {{this}}</div>{{/forEach}}
  //      Output: <div>name = Mike</div><div>age = 30</div><div>city = New York</div><div>country = USA</div>
  //
  //      {{#forEach begin=1 end=7}}<li>{{this}}</li>{{/forEach}}
  //      Output: <li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li>
  Handlebars.registerHelper('forEach', function (options) {
    const hash = options.hash || {};
    const items = hash.items;
    let begin = hash.begin || 0;
    let end;
    let step = hash.step || 1;
    let data;
    let i;
    let count = 1;
    let keys;
    let key;
    let output = '';
    const types = {
      ARRAY: 'array',
      MAP: 'map',
      LOOP: 'loop',
    };
    let type;

    function setData() {
      if (data) {
        const nextIndex = i + step;
        data.index = i;
        data.count = count;
        data.first = i === begin;
        data.last = nextIndex > end;
        if (key) {
          data.key = key;
        }
      }
    }

    function getContext() {
      let context;
      if (type === types.LOOP) {
        context = i;
      } else if (type === types.ARRAY) {
        context = items[i];
      } else if (type === types.MAP) {
        context = items[keys[i]];
      }
      return context;
    }

    function updateEnd(list) {
      end = hash.end || list.length;
      if (end > list.length - 1) {
        end = list.length - 1;
      }
    }

    if (options.data) {
      data = Handlebars.createFrame(options.data);
    }

    try {
      if (items && typeof items === 'object') {
        if (Array.isArray(items)) {
          updateEnd(items);
          type = types.ARRAY;
        } else {
          keys = Object.keys(items);
          updateEnd(keys);
          type = types.MAP;
        }
      } else {
        end = hash.end || 0;
        type = types.LOOP;
      }
    } catch (err) {
      Logger.error('Caught exception in forEach helper: ', err);
      return '';
    }

    // Make sure these are actually numbers
    begin = parseInt(begin, 10);
    end = parseInt(end, 10);
    step = parseInt(step, 10);

    // Error checking.  Begin, end, step must be integers and beging must be less than end
    if (Number.isNaN(Number(begin))) {
      throw new Error('begin must be an integer');
    }
    if (Number.isNaN(Number(end))) {
      throw new Error('end must be an integer');
    }
    if (Number.isNaN(Number(step))) {
      throw new Error('step must be an integer');
    }
    if (begin < 0) {
      throw new Error('begin must be 0 or greater');
    }
    if (step < 0) {
      throw new Error('step must be a positive integer');
    }

    for (i = begin; i <= end; i += step, count++) {
      if (type === types.MAP) {
        key = keys[i];
      }
      setData();
      output += options.fn(getContext(), {
        data,
      });
    }

    // If the loop does not execute then do the else path
    if (i === begin) {
      output = options.inverse(this);
    }

    return output;
  });

  module.exports = Handlebars;
}
