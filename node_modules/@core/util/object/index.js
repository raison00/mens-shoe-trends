// #MODULE - ObjectUtils
// > Author: Sarfaraz Merchant
// >
// > Create Date: <July 23, 2014>
// >
// ##DESCRIPTION: This module will handle string manipulation
// >
module.exports = (function () {
  // ###Method - hasChildProperty( obj, propPath )
  // Public method to check if object contains a particular property at a give path.
  //
  // > parameters
  // >
  // + *obj* - *Object* Object that will looked for a particular property
  // + *propPath* - *String* Property path to look
  //
  // > returns
  // >
  // + *boolean* - true/false depending on outcome of analyzing object
  //
  function hasChildProperty(object, pPath) {
    let propPath = pPath;
    let obj = object;
    let i = 0;
    let part;

    if (!obj || typeof obj !== 'object' || !propPath || typeof propPath !== 'string') {
      return false;
    }

    // strip a leading dot
    propPath = propPath.replace(/^\./, '');
    const path = propPath.split('.');
    const length = path.length;

    for (; i < length; i++) {
      part = path[i];
      if (!obj || !Object.prototype.hasOwnProperty.call(obj, part)) {
        return false;
      }
      obj = obj[part];
    }
    return true;
  }

  // ###Method - getChildProperty( obj, propPath )
  // Public method to get deep nested property value when property path is string.
  //
  // > parameters
  // >
  // + *obj* - *Object* Object that will looked for a particular property
  // + *propPath* - *String* Property path to look
  //
  // > returns
  // >
  // + *value* - will return whatever is the value of the property
  //
  function getChildProperty(object, pPath) {
    let propPath = pPath;
    let obj = object;
    let i = 0;
    let part;

    if (!obj || typeof obj !== 'object' || !propPath || typeof propPath !== 'string') {
      // don't know what to return here because property can have any type of value undefined, false, etc...
      // may be we should just throw an error. or some random string to indicate an error
      return undefined;
    }

    // convert indexes to properties for example [0] will become .0
    propPath = propPath.replace(/\[(\w+)\]/g, '.$1');
    // strip a leading dot
    propPath = propPath.replace(/^\./, '');
    const path = propPath.split('.');
    const length = path.length;

    for (; i < length; i++) {
      part = path[i];
      if (typeof obj === 'object' && part in obj) {
        obj = obj[part];
      } else {
        return undefined;
      }
    }
    return obj;
  }

  // ###Method - setChildProperty( obj, propPath )
  // Public method to get deep nested property value when property path is string.
  //
  // > parameters
  // >
  // + *value* - *Any data type* Value of the child property that you want to set
  // + *propPath* - *String* Property path to look
  // + *obj* - *Object | Optional* Object on which child property will be set.
  // + If nothing is passed an empty will be created before setting child property
  //
  // > returns
  // >
  // + *obj* - will return obj
  //
  function setChildProperty(value, pPath, object) {
    let obj = object;
    let propPath = pPath;
    let i = 0;
    let part;

    obj = obj || {};

    if (!propPath || typeof propPath !== 'string') {
      // don't know what to return here because property can have any type of value undefined, false, etc...
      // may be we should just throw an error. or some random string to indicate an error
      return undefined;
    }

    // convert indexes to properties for example [0] will become .0
    // propPath = propPath.replace( /\[(\w+)\]/g, '.$1' );
    // strip a leading dot
    propPath = propPath.replace(/^\./, '');
    const path = propPath.split('.');
    const length = path.length - 1;

    for (; i < length; i++) {
      part = path[i];
      if (!(part in obj)) {
        obj[part] = {};
      }
      obj = obj[part];
    }
    obj[path[length]] = value;
    return obj;
  }


  // Immediate Invoke Function (IIFE)
  // This function will be used add methods to Object object as soon as ObjectUtils.js is loaded
  // Since ObjectUtils.js is part of McomBase.js it will get executed before any page specfic modules are loaded, as long as they depend on
  // this module.
  //
  // > parameters
  // + none
  //
  // > returns
  // + none
  //
  (function () {
    // POLYFILL: Object.keys - IE <= 9 does not support this method.  The below will check if it is already a part of the Object,
    // and if not, then it will add it with this polyfill
    // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
    if (!Object.keys) {
      Object.keys = (function () {
        const hasOwnProperty = Object.prototype.hasOwnProperty;
        const hasDontEnumBug = !Object.prototype.propertyIsEnumerable({ // eslint-disable-line no-prototype-builtins
          toString: null,
        }, 'toString');
        const dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor',
        ];
        const dontEnumsLength = dontEnums.length;

        return function (obj) {
          if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
            throw new TypeError('Object.keys called on non-object');
          }

          const result = [];
          let i;

          Object.keys(obj).forEach((prop) => {
            if (hasOwnProperty.call(obj, prop)) {
              result.push(prop);
            }
          });

          if (hasDontEnumBug) {
            for (i = 0; i < dontEnumsLength; i++) {
              if (hasOwnProperty.call(obj, dontEnums[i])) {
                result.push(dontEnums[i]);
              }
            }
          }
          return result;
        };
      }());
    }
  }());

  return {
    hasChildProperty,
    getChildProperty,
    setChildProperty,

  };
}());
