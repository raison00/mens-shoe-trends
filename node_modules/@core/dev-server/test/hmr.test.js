import test from 'ava';
import stripAnsi from 'strip-ansi';
import { stub, match, createStubInstance } from 'sinon';

const proxyquire = require('proxyquire').noPreserveCache();

let processOnStub;
let renderBundle;
let webpack;
let webpackDevMiddleware;
let webpackHotMiddleware;
let hotModuleReplacementPlugin;
let compiler;
let stats;
let hmr;
let context;

const clientCompiler = (errors = []) => {
  stats = { toJson: () => ({ errors }) };
  return { plugin: stub().yields(stats) };
};

// process.on will yell for too many attachments. just stub it
test.before(() => {
  processOnStub = stub(process, 'on');
});

test.beforeEach(() => {
  processOnStub.reset();
  renderBundle = stub().resolves();
  webpack = stub();
  webpackDevMiddleware = stub().returns('dev-middleware');
  webpackHotMiddleware = stub().returns('hot-middleware');
  webpack.HotModuleReplacementPlugin = stub();
  hotModuleReplacementPlugin = createStubInstance(webpack.HotModuleReplacementPlugin);
  compiler = clientCompiler();

  hmr = proxyquire('../lib/hmr', {
    webpack: webpack.returns(compiler),
    'webpack-dev-middleware': webpackDevMiddleware,
    'webpack-hot-middleware': webpackHotMiddleware,
    '@core/build/config/webpack.client': ({
      output: {
        publicPath: 'foo/bar',
      },
      entry: {
        foo: 'entry-foo.js',
        bar: 'entry-bar.js',
        baz: 'entry-baz.js',
      },
      plugins: ['foo'],
      '@noCallThru': true,
    }),
    '@core/lib/render-bundle': renderBundle,
  });

  context = {
    app: {
      use: stub(),
    },
  };
});

test.after(() => {
  process.on.restore();
});

test('should export a function', (t) => {
  t.is(typeof hmr, 'function');
});

test('should instantiate HotModuleReplacementPlugin', async (t) => {
  await hmr.apply(context);
  t.true(webpack.HotModuleReplacementPlugin.calledOnce);
  t.true(webpack.HotModuleReplacementPlugin.calledWithNew());
  t.pass();
});

test('should compile with a modified webpack config', async (t) => {
  await hmr.apply(context);
  t.true(webpack.calledOnce);
  t.true(webpack.calledWithExactly({
    output: {
      filename: '[name].js',
      publicPath: 'foo/bar',
    },
    entry: {
      foo: ['webpack-hot-middleware/client', 'entry-foo.js'],
      bar: ['webpack-hot-middleware/client', 'entry-bar.js'],
      baz: ['webpack-hot-middleware/client', 'entry-baz.js'],
    },
    plugins: ['foo', hotModuleReplacementPlugin],
    '@noCallThru': true,
  }));
});

test('should initialize dev middleware with the compiler and correct config', async (t) => {
  await hmr.apply(context);
  t.true(webpackDevMiddleware.calledOnce);

  t.true(webpackDevMiddleware.calledWithExactly(compiler, {
    publicPath: 'foo/bar',
    stats: { colors: true },
  }));
});

test('should attach the dev middleware to the express app', async (t) => {
  await hmr.apply(context);
  t.true(context.app.use.calledWithExactly('dev-middleware'));
});

test('should attach a "done" listener to the client compiler', async (t) => {
  await hmr.apply(context);
  t.true(webpackDevMiddleware.calledOnce);

  t.true(webpackDevMiddleware.calledWithExactly(compiler, {
    publicPath: 'foo/bar',
    stats: { colors: true },
  }));
});

test('should initialize hot middleware with the compiler', async (t) => {
  await hmr.apply(context);
  t.true(webpackHotMiddleware.calledOnce);
  t.true(webpackHotMiddleware.calledWithExactly(compiler));
});

test('should attach the hot middleware to the express app', async (t) => {
  await hmr.apply(context);
  t.true(context.app.use.calledWithExactly('hot-middleware'));
});

test('should render the bundle if the compiler does not contain errors', async (t) => {
  await hmr.apply(context);
  t.true(renderBundle.calledOnce);
  t.is(renderBundle.thisValues[0], context);
  t.true(renderBundle.calledWithExactly(stats));
});

// must be serial since it modifies what the webpack spy returns, which is referenced by the
// common proxyrequire used by parallel tests
test.serial('should not render the bundle if the compiler contains errors', async (t) => {
  const compilerWithErrors = clientCompiler(['something messed up']);
  webpack.returns(compilerWithErrors);
  await t.throws(hmr.apply(context));
  t.false(renderBundle.called);
});

// must be serial since it modifies what the renderBundle spy returns, which is referenced by the
// common proxyrequire used by parallel tests
test.serial('should reject if there is an error rendering the bundle', async (t) => {
  renderBundle.rejects();
  await t.throws(hmr.apply(context));
  t.true(renderBundle.calledOnce);
});

test('should listen to messages sent by the process runner', async (t) => {
  await hmr.apply(context); // first render
  t.true(process.on.calledWithExactly('message', match.func));
});

// serial since it stubs console.log and changes behavior of process.on and webpack compiler
test.serial('should not re-render the bundle if the entry message is received and stats dont exist', async (t) => {
  stub(console, 'log');
  const compilerWithErrors = clientCompiler(['something messed up']);
  webpack.returns(compilerWithErrors);
  process.on.yields({ entry: 'foo' });
  await t.throws(hmr.apply(context));

  t.false(renderBundle.calledWith(stats, 'foo'));
  t.false(console.log.called); // eslint-disable-line no-console
  console.log.restore(); // eslint-disable-line no-console
});

// serial since it stubs console.log and changes behavior of process.on
test.serial('should not re-render the bundle if the entry message is not received and stats exist', async (t) => {
  stub(console, 'log');
  process.on.yields();
  await hmr.apply(context);

  t.false(renderBundle.calledWith(stats, 'foo'));
  t.false(console.log.called); // eslint-disable-line no-console
  console.log.restore(); // eslint-disable-line no-console
});

// serial since it stubs console.log and changes behavior of process.on
test.serial('should re-render the bundle if the entry message is received and stats exist', async (t) => {
  stub(console, 'log');
  process.on.yields({ entry: 'foo' });
  await hmr.apply(context); // first render

  t.true(renderBundle.calledWith(stats, 'foo'));
  t.true(console.log.calledOnce); // eslint-disable-line no-console
  t.is(stripAnsi(console.log.getCall(0).args[0]), 'rebuilt index.html for foo'); // eslint-disable-line no-console
  console.log.restore(); // eslint-disable-line no-console
});

test('should re-render the bundle each time webpack compile finishes', async (t) => {
  await hmr.apply(context); // first render
  const callback = compiler.plugin.getCall(0).args[1];

  callback(stats);
  callback(stats);
  callback(stats);

  t.is(renderBundle.callCount, 4);
});
