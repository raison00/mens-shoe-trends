/**
 * The system will attempt to automatically determine entry points. It will scan the project
 * directory for files named "app-*.js", and create entry points by extracting the name from the
 * filepath. For example, if a project has the following:
 *
 *   app-bcom.js
 *   app-mcom.js
 *
 * ...the entry points "bcom" and "mcom" will be extracted.
 *
 * By default, this function will only return a single entry point. Pass options.name to return
 * info for the particular entry point (or simply validate it). For multi-entry point projects,
 * if options.name is omitted, the function will return the first entry point found.
 *
 * For single entry point projects, undefined will be returned.
 *
 * If options.expand = true, this function will return a configuration object in the following
 * format:
 *
 *   {
 *     name: 'bcom',
 *     path: '/full/path/to/project/app-bcom.js',
 *   }
 *
 * For single entry point projects, the entry point name will be omitted, i.e.
 *
 *   {
 *     path: '/full/path/to/project/app.js',
 *   }
 *
 * Paths are resolved relative to the project directory, joined with options.root (which defaults
 * to an empty string). If options.root is changed to "tests", for example, the same path
 * above would instead resolve to:
 *
 *   {
 *     path: '/full/path/to/project/tests/app.js',
 *   }
 *
 * By default, this function will only return a single entry point. To override this behavior, set
 * options.all = true. This will return an array of strings by default, or a configuration object
 * with all entry points and paths if options.expand = true. For example:
 *   without options.expand = true:
 *
 *   ['mcom', 'bcom']
 *
 *   with options.expand = true:
 *
 *   [{
 *     name: 'bcom',
 *     path: '/full/path/to/project/app-bcom.js',
 *   }, {
 *     name: 'mcom',
 *     path: '/full/path/to/project/app-mcom.js',
 *   }]
 */
const _ = require('lodash');
const chalk = require('chalk');
const fs = require('fs-extra');
const path = require('path');
const resolve = require('@core/lib/project/resolve');

module.exports = (options = {}) => {
  const root = resolve(options.root || '');

  // needs to be synchronous, because is consumed by webpack config at compile-time
  const entryPoints = _.transform(fs.readdirSync(root), (result, file) => {
    const extension = path.extname(file);
    const basename = path.basename(file, extension);

    if (extension === '.js' && _.startsWith(basename, 'app')) {
      const config = { path: path.join(root, (basename + extension)) };
      const matches = basename.match(/app-(.+)/);

      if (matches) {
        // this entry point is named, i.e. app-[name].js, e.g. app-mcom. entry point is [name]
        config.name = matches[1]; // eslint-disable-line prefer-destructuring
      }

      result.push(config);
    }
  }, []);

  if (entryPoints.length === 0) {
    if (root.endsWith('/tests')) {
      throw new Error(`Could not find app.js or app-*.js in the tests directory: ${root}`);
    } else {
      throw new Error(`Could not find app.js or app-*.js in the project root: ${root}`);
    }
  }

  // for multi-entry projects, they may have both src/app-* files and a shared src/app.js file.
  // This pattern should NOT be considered an entry file and should be omitted
  if (entryPoints.length > 1) {
    const notReallyAnEntryPoint = _.findIndex(entryPoints, entry => !entry.name);

    if (notReallyAnEntryPoint > -1) {
      _.pullAt(entryPoints, notReallyAnEntryPoint);
    }
  }

  // By default only a single entry point is returned. options.all overrides this behavior.
  if (options.all) {
    return options.expand ? entryPoints : _.map(entryPoints, 'name');
  }

  let entryPoint;
  if (options.name && entryPoints.length > 1) {
    entryPoint = _.find(entryPoints, { name: options.name });
    if (!entryPoint) {
      throw new Error(`${options.name} is not a valid entry point`);
    }
  } else if (entryPoints.length > 1) {
    // for multi-entry projects, if no name is supplied, assume the first entry point found
    [entryPoint] = entryPoints;
    console.warn(chalk.bold.yellow(`No entry point supplied; assuming ${entryPoint.name}`)); // eslint-disable-line no-console
  } else {
    // single-entry project
    [entryPoint] = entryPoints;
  }

  return options.expand ? entryPoint : _.get(entryPoint, 'name'); // entryPoint might be undefined
};
