import path from 'path';
import { stub } from 'sinon';
import test from 'ava';

const proxyquire = require('proxyquire').noPreserveCache();

let entryPoint;
let readdirSync;
let resolve;

test.before(() => {
  readdirSync = stub();
  resolve = stub();

  entryPoint = proxyquire('./entry-point', {
    'fs-extra': { readdirSync },
    '@core/lib/project/resolve': resolve,
  });

  stub(console, 'warn');
});

test.after(() => {
  console.warn.restore(); // eslint-disable-line no-console
});

test.beforeEach(() => {
  readdirSync.reset();
  resolve.reset();
  readdirSync.returns(['asdf.js', 'app-foo.js', 'app-bar.js', 'app-baz.js']);
  resolve.callsFake(root => path.join('/full/path/to/project', root));
});

test('it should resolve the project root by default', (t) => {
  entryPoint();
  t.true(resolve.calledOnce);
  t.true(resolve.calledWithExactly(''));
});

test('it should resolve the project root relative to options.root', (t) => {
  entryPoint({ root: 'foo/bar/baz' });

  t.true(resolve.calledOnce);
  t.true(resolve.calledWithExactly('foo/bar/baz'));
});

test('it should scan the project directory for project files', (t) => {
  entryPoint();
  t.true(readdirSync.calledWithExactly('/full/path/to/project'));
});

test('it should return undefined for single entry point projects', (t) => {
  readdirSync.returns(['app.js']);
  t.is(entryPoint(), undefined);
});

test('it should return an object with path for single entry point projects if options.expand=true', (t) => {
  readdirSync.returns(['app.js']);

  t.deepEqual(entryPoint({ expand: true }), {
    path: '/full/path/to/project/app.js',
  });
});

test('it should return the entry point string matching options.name', (t) => {
  t.is(entryPoint({ name: 'bar' }), 'bar');
});

test('it should return the entry point object matching options.name if options.expand=true', (t) => {
  t.deepEqual(entryPoint({ name: 'bar', expand: true }), {
    name: 'bar',
    path: '/full/path/to/project/app-bar.js',
  });
});

test('it should throw an error if options.name is not a valid entry point', (t) => {
  t.throws(() => entryPoint({ name: 'asdf' }), 'asdf is not a valid entry point');
});

test('it should return the first entry point string if !options.name', (t) => {
  t.is(entryPoint(), 'foo');
});

test('it should return the first entry point object if !options.name options.expand=true', (t) => {
  t.deepEqual(entryPoint({ expand: true }), {
    name: 'foo',
    path: '/full/path/to/project/app-foo.js',
  });
});

test('it should return all entry point strings if options.all=true', (t) => {
  t.deepEqual(entryPoint({ all: true }), ['foo', 'bar', 'baz']);
});

test('it should return all entry point objects if options.all=true and options.expand=true', (t) => {
  t.deepEqual(entryPoint({ expand: true, all: true }), [
    { name: 'foo', path: '/full/path/to/project/app-foo.js' },
    { name: 'bar', path: '/full/path/to/project/app-bar.js' },
    { name: 'baz', path: '/full/path/to/project/app-baz.js' },
  ]);
});

test('it should append whatever root is supplied to the result, for a single entry point', (t) => {
  readdirSync.returns(['app.js']);

  t.deepEqual(entryPoint({ root: 'foo/bar', expand: true }), {
    path: '/full/path/to/project/foo/bar/app.js',
  });
});

test('it should append whatever root is supplied to the result, for multiple entry points', (t) => {
  t.deepEqual(entryPoint({ root: 'foo/bar', expand: true, all: true }), [
    { name: 'foo', path: '/full/path/to/project/foo/bar/app-foo.js' },
    { name: 'bar', path: '/full/path/to/project/foo/bar/app-bar.js' },
    { name: 'baz', path: '/full/path/to/project/foo/bar/app-baz.js' },
  ]);
});

test('it should not treat "app.js" as entry point for multi-entry projects', (t) => {
  readdirSync.returns(['asdf.js', 'app.js', 'app-foo.js', 'app-bar.js', 'app-baz.js']);
  t.deepEqual(entryPoint({ all: true }), ['foo', 'bar', 'baz']);
});
