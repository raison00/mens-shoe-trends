/* eslint-disable import/first,no-underscore-dangle */
// Handle conflicting copies of babel polyfill - https://github.com/lebab/lebab/issues/249
if ((typeof window !== 'undefined' && !window._babelPolyfill) ||
  (typeof global !== 'undefined' && !global._babelPolyfill)) {
  require('babel-polyfill');
}

/**
 * @file entry.js
 *
 * The entry point for every client side application
 */

import store from '@core/lib/store';

if (window.__INITIAL_STATE__) {
  store.replaceState(window.__INITIAL_STATE__);

  const { ASSET_HOST, PUBLIC_PATH_PREFIX } = store.get('properties') || {};
  /* eslint-disable no-undef,camelcase */
  if (typeof PUBLIC_PATH_PREFIX !== 'undefined') {
    __webpack_public_path__ = PUBLIC_PATH_PREFIX + __webpack_public_path__;
  }

  if (ASSET_HOST && __webpack_public_path__.indexOf('http') !== 0 && __webpack_public_path__.indexOf('//') !== 0) {
    // @TODO verify this doesn't cause issues for being lazy-loaded (i.e. app.js lazy loads in outer event loop)
    __webpack_public_path__ = ASSET_HOST + __webpack_public_path__;
  }
  /* eslint-enable no-undef,camelcase */
}

const appPath = process.env.APP_PATH; // comes from webpack.client.js
const isLibrary = process.env.IS_LIBRARY; // comes from webpack.client.js
let app;

const initialize = () => {
  // must pass process.env.APP_PATH directly to require() or the compiler fails
  const m = require(process.env.APP_PATH); // eslint-disable-line import/no-dynamic-require
  app = m.default || m; // backwards support for ES5 modules

  if (!isLibrary) {
    if (!app.start) {
      throw new Error(`Expected an app.start() method exported by ${appPath}`);
    }

    // defer JS execution to ensure <body> exists and store is set up
    setTimeout(() => {
      app.start();
    }, 0);
  }
};

initialize();

/**
 * Enable HMR client-side. Allows changes to project files to be reflected almost immediately in the browser, without
 * requiring any action. It works by injecting the new bundle, and then calling whatever method is triggered by hot.accept().
 *
 * In this case, initialize() is called. It will load the new changes to app(-*).js and execute app.start().
 *
 * IMPORTANT: app.start() should be idempotent in every project. Any global state needs to be cleaned up whenever
 * app.start() is called, or else there could be unintended side-effects. Examples of global state are things
 * attached to window, e.g. Backbone.History or global $() jQuery events.
 *
 * These side-effects can be circumvented by simply reloading, but that is also circumventing the benefits.
 */
if (module.hot) {
  module.hot.accept(process.env.APP_PATH, initialize);
}

module.exports = app; // CommonJS so that libraries dont have to access ".default"
