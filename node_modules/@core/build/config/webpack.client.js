const _ = require('lodash');
const path = require('path');
const webpack = require('webpack');
const merge = require('webpack-merge');
const pkg = require('@core/lib/project/pkg')();
const baseConfig = require('./webpack.base');

const entryPoint = require('../lib/entry-point')({
  name: process.env.ENTRY_POINT,
  expand: true,
}) || {};

const entryPointPath = entryPoint.path;
const entryPointName = entryPoint.name;

const isLibrary = _.get(pkg, 'config.build.library') === true;

const plugins = [
  new webpack.DefinePlugin({
    'process.env.APP_PATH': JSON.stringify(entryPointPath), // used by ../lib/entry.js
    'process.env.APP_ENV': JSON.stringify('client'), // used to determine client vs. server in universal js modules
    'process.env.ENTRY_POINT': JSON.stringify(entryPointName), // replace context.load with this
    'process.env.IS_LIBRARY': JSON.stringify(isLibrary), // changes behavior in entry.js
    'process.env.ASSET_HOST': JSON.stringify(process.env.ASSET_HOST || ''), // used by ../lib/entry.js
    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'),
    'process.env.PORT': JSON.stringify(process.env.PORT || 8081),
    'process.env.TAG_MNGR_ENV': JSON.stringify(process.env.TAG_MNGR_ENV || 'dev'),
  }),
];

// CommonsChunkPlugin does not play nicely with karma
if (process.env.NODE_ENV !== 'test') {
  plugins.push(new webpack.optimize.CommonsChunkPlugin({
    name: 'vendor',
    async: true,
    children: true,
    minChunks(module) {
      // a module is extracted into the vendor chunk if...
      return (
        // it's inside node_modules
        /node_modules/.test(module.context) &&
        // and not a CSS file (due to extract-text-webpack-plugin limitation)
        !/\.css$/.test(module.request)
      );
    },
  }));

  /**
   * By default, the webpack runtime & manifest will be extracted out into a separate file from the application itself.
   * This is a caching/performance enhancement. @see https://webpack.js.org/plugins/commons-chunk-plugin/#manifest-file
   * However, library projects should override this behavior so the manifest bundled with the library itself. This enables
   * third party scripts access to the library interface using a single <script> tag without having to load the manifest first.
   */
  if (!isLibrary) {
    plugins.push(new webpack.optimize.CommonsChunkPlugin({
      name: 'manifest',
      minChunks: Infinity,
    }));
  }
}

module.exports = merge(baseConfig, {
  entry: { [entryPointName || 'app']: path.resolve(__dirname, '../lib/entry') },
  plugins,

  /**
   * @TODO remove this ASAP!
   *
   * Major performance implications having this here. It exists to allow projects to require 'handlebars'.
   *
   * The handlebars library is 4x larger than the core 'handlebars/runtime' files, and is a major anti-pattern
   * for browser compilation.
   *
   * It additionally includes the template strings for every single known template for the project, which includes
   * all of its children dependencies, recursively. This means the final bundle can potentially be orders of
   * magnitude larger (depending on how many templates exist recursively, and how large they are).
   *
   * Lastly, it enables the ability to compile templates at runtime (usually indirectly without being aware),
   * which is a very computationally-expensive operation for the client, especially when it comes to less-powerful
   * mobile device platforms.
   *
   * @see http://handlebarsjs.com/precompilation.html
   */
  node: { fs: 'empty' },
});
