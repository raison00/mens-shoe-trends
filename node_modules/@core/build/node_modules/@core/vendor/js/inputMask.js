/* eslint-disable */
// jshint ignore: start
// jQuery Mask Plugin v1.13.9
// github.com/igorescobar/jQuery-Mask-Plugin
(function(a) {
  typeof define === 'function' && define.amd
    ? define(['jquery'], a)
    : typeof exports === 'object'
      ? (module.exports = a(require('jquery')))
      : a(jQuery || Zepto);
})(a => {
  const x = function(c, e, d) {
    const b = {
      invalid: [],
      getCaret() {
        try {
          let r,
            a = 0,
            e = c.get(0),
            f = document.selection,
            d = e.selectionStart;
          if (f && navigator.appVersion.indexOf('MSIE 10') === -1)
            (r = f.createRange()), r.moveStart('character', -b.val().length), (a = r.text.length);
          else if (d || d === '0') a = d;
          return a;
        } catch (h) {}
      },
      setCaret(r) {
        try {
          if (c.is(':focus')) {
            let b;
            b = c.get(0).createTextRange();
            b.collapse(!0);
            b.moveEnd('character', r);
            b.moveStart('character', r);
            b.select();
          }
        } catch (a) {}
      },
      events() {
        c
          .on('keydown.mask', b => {
            c.data('mask-keycode', b.keyCode || b.which);
          })
          .on(a.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', b.behaviour)
          .on('paste.mask drop.mask', () => {
            setTimeout(() => {
              c.keydown().keyup();
            }, 100);
          })
          .on('change.mask', () => {
            c.data('changed', !0);
          })
          .on('blur.mask', () => {
            n === b.val() || c.data('changed') || c.trigger('change');
            c.data('changed', !1);
          })
          .on('blur.mask', () => {
            n = b.val();
          })
          .on('focus.mask', b => {
            !0 === d.selectOnFocus && a(b.target).select();
          })
          .on('focusout.mask', () => {
            d.clearIfNotMatch && !k.test(b.val()) && b.val('');
          });
      },
      getRegexMask() {
        for (var b = [], c, a, f, d, h = 0; h < e.length; h++) {
          (c = g.translation[e.charAt(h)])
            ? ((a = c.pattern.toString().replace(/.{1}$|^.{1}/g, '')),
              (f = c.optional),
              (c = c.recursive)
                ? (b.push(e.charAt(h)),
                  (d = {
                    digit: e.charAt(h),
                    pattern: a,
                  }))
                : b.push(f || c ? `${a}?` : a))
            : b.push(e.charAt(h).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
        }
        b = b.join('');
        d && (b = b.replace(new RegExp(`(${d.digit}(.*${d.digit})?)`), '($1)?').replace(new RegExp(d.digit, 'g'), d.pattern));
        return new RegExp(b);
      },
      destroyEvents() {
        c.off('input keydown keyup paste drop blur focusout '.split(' ').join('.mask '));
      },
      val(b) {
        let a = c.is('input') ? 'val' : 'text';
        if (arguments.length > 0) {
          if (c[a]() !== b) c[a](b);
          a = c;
        } else a = c[a]();
        return a;
      },
      getMCharsBeforeCount(b, c) {
        for (var a = 0, d = 0, l = e.length; d < l && d < b; d++) g.translation[e.charAt(d)] || ((b = c ? b + 1 : b), a++);
        return a;
      },
      caretPos(c, a, d, f) {
        return g.translation[e.charAt(Math.min(c - 1, e.length - 1))] ? Math.min(c + d - a - f, d) : b.caretPos(c + 1, a, d, f);
      },
      behaviour(d) {
        d = d || window.event;
        b.invalid = [];
        const e = c.data('mask-keycode');
        if (a.inArray(e, g.byPassKeys) === -1) {
          let p = b.getCaret(),
            f = b.val().length,
            l = b.getMasked(),
            h = l.length,
            n = b.getMCharsBeforeCount(h - 1) - b.getMCharsBeforeCount(f - 1),
            m = p < f;
          b.val(l);
          m && (e !== 8 && e !== 46 && (p = b.caretPos(p, f, h, n)), b.setCaret(p));
          return b.callbacks(d);
        }
      },
      getMasked(c) {
        const a = [];
        const p = b.val();
        let f = 0;
        const l = e.length;
        let h = 0;
        const n = p.length;
        let m = 1;
        let k = 'push';
        let t = -1;
        let s;
        let v;
        d.reverse
          ? ((k = 'unshift'),
            (m = -1),
            (s = 0),
            (f = l - 1),
            (h = n - 1),
            (v = function() {
              return f > -1 && h > -1;
            }))
          : ((s = l - 1),
            (v = function() {
              return f < l && h < n;
            }));
        for (; v(); ) {
          const w = e.charAt(f);
          const u = p.charAt(h);
          const q = g.translation[w];
          if (q) {
            u.match(q.pattern)
              ? (a[k](u), q.recursive && (t === -1 ? (t = f) : f === s && (f = t - m), s === t && (f -= m)), (f += m))
              : q.optional
                ? ((f += m), (h -= m))
                : q.fallback
                  ? (a[k](q.fallback), (f += m), (h -= m))
                  : b.invalid.push({
                      p: h,
                      v: u,
                      e: q.pattern,
                    }),
              (h += m);
          } else {
            if (!c) a[k](w);
            u === w && (h += m);
            f += m;
          }
        }
        c = e.charAt(s);
        l !== n + 1 || g.translation[c] || a.push(c);
        return a.join('');
      },
      callbacks(a) {
        const g = b.val();
        const k = g !== n;
        const f = [g, a, c, d];
        const l = function(b, c, a) {
          typeof d[b] === 'function' && c && d[b].apply(this, a);
        };
        l('onChange', !0 === k, f);
        l('onKeyPress', !0 === k, f);
        l('onComplete', g.length === e.length, f);
        l('onInvalid', b.invalid.length > 0, [g, a, c, b.invalid, d]);
      },
    };
    c = a(c);
    let g = this;
    let n = b.val();
    let k;
    e = typeof e === 'function' ? e(b.val(), void 0, c, d) : e;
    g.mask = e;
    g.options = d;
    g.remove = function() {
      const a = b.getCaret();
      b.destroyEvents();
      b.val(g.getCleanVal());
      b.setCaret(a - b.getMCharsBeforeCount(a));
      return c;
    };
    g.getCleanVal = function() {
      return b.getMasked(!0);
    };
    g.init = function(e) {
      e = e || !1;
      d = d || {};
      g.clearIfNotMatch = a.jMaskGlobals.clearIfNotMatch;
      g.byPassKeys = a.jMaskGlobals.byPassKeys;
      g.translation = a.extend({}, a.jMaskGlobals.translation, d.translation);
      g = a.extend(!0, {}, g, d);
      k = b.getRegexMask();
      !1 === e
        ? (d.placeholder && c.attr('placeholder', d.placeholder),
          c.data('mask') && c.attr('autocomplete', 'off'),
          b.destroyEvents(),
          b.events(),
          (e = b.getCaret()),
          b.val(b.getMasked()),
          b.setCaret(e + b.getMCharsBeforeCount(e, !0)))
        : (b.events(), b.val(b.getMasked()));
    };
    g.init(!c.is('input'));
  };
  a.maskWatchers = {};
  let z = function() {
      const c = a(this);
      const e = {};
      const d = c.attr('data-mask');
      c.attr('data-mask-reverse') && (e.reverse = !0);
      c.attr('data-mask-clearifnotmatch') && (e.clearIfNotMatch = !0);
      c.attr('data-mask-selectonfocus') === 'true' && (e.selectOnFocus = !0);
      if (y(c, d, e)) return c.data('mask', new x(this, d, e));
    },
    y = function(c, e, d) {
      d = d || {};
      const b = a(c).data('mask');
      const g = JSON.stringify;
      c = a(c).val() || a(c).text();
      try {
        return typeof e === 'function' && (e = e(c)), typeof b !== 'object' || g(b.options) !== g(d) || b.mask !== e;
      } catch (k) {}
    };
  a.fn.mask = function(c, e) {
    e = e || {};
    const d = this.selector;
    var b = a.jMaskGlobals;
    const g = b.watchInterval;
    var b = e.watchInputs || b.watchInputs;
    const k = function() {
      if (y(this, c, e)) return a(this).data('mask', new x(this, c, e));
    };
    a(this).each(k);
    d &&
      d !== '' &&
      b &&
      (clearInterval(a.maskWatchers[d]),
      (a.maskWatchers[d] = setInterval(() => {
        a(document)
          .find(d)
          .each(k);
      }, g)));
    return this;
  };
  a.fn.unmask = function() {
    clearInterval(a.maskWatchers[this.selector]);
    delete a.maskWatchers[this.selector];
    return this.each(function() {
      const c = a(this).data('mask');
      c && c.remove().removeData('mask');
    });
  };
  a.fn.cleanVal = function() {
    return this.data('mask').getCleanVal();
  };
  a.applyDataMask = function(c) {
    c = c || a.jMaskGlobals.maskElements;
    (c instanceof a ? c : a(c)).filter(a.jMaskGlobals.dataMaskAttr).each(z);
  };
  let k = {
    maskElements: 'input,td,span,div',
    dataMaskAttr: '*[data-mask]',
    dataMask: !0,
    watchInterval: 300,
    watchInputs: !0,
    useInput: (function(a) {
      const e = document.createElement('div');
      let d;
      a = `on${a}`;
      d = a in e;
      d || (e.setAttribute(a, 'return;'), (d = typeof e[a] === 'function'));
      return d;
    })('input'),
    watchDataMask: !1,
    byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],
    translation: {
      0: {
        pattern: /\d/,
      },
      9: {
        pattern: /\d/,
        optional: !0,
      },
      '#': {
        pattern: /\d/,
        recursive: !0,
      },
      A: {
        pattern: /[a-zA-Z0-9]/,
      },
      S: {
        pattern: /[a-zA-Z]/,
      },
    },
  };
  a.jMaskGlobals = a.jMaskGlobals || {};
  k = a.jMaskGlobals = a.extend(!0, {}, k, a.jMaskGlobals);
  k.dataMask && a.applyDataMask();
  setInterval(() => {
    a.jMaskGlobals.watchDataMask && a.applyDataMask();
  }, k.watchInterval);
});
