/**
 * Server-side application bundle renderer.
 *
 * Currently, simply renders the index file with webpack-generated JS/CSS asset paths as the
 * template context.
 *
 * If stats are included (i.e. when in dev mode and HMR is re-compiling), will parse webpack stats
 * into JS/CSS asset paths.
 *
 * Else (i.e. production build), attempt to read from assets.json in the outputPath.
 *
 * Function can consume a particular entry point. Omit to render for the entry point defined by
 * process.env.ENTRY_POINT. If no entry point is resolved, render for all entry points.
 */
const chalk = require('chalk');
const ejs = require('ejs');
const fs = require('fs-extra');
const path = require('path');
const _ = require('lodash');
const extractAssets = require('../webpack/lib/extract-assets');
const outputPath = require('../project/output-path');
const resolve = require('../project/resolve');

const prependRuntimeOutputPath = (obj) => {
  const outputObject = obj;
  Object.keys(obj).forEach((key) => {
    if (_.isArray(obj[key])) {
      outputObject[key] = _.map(obj[key], filepath => process.env.PUBLIC_PATH_PREFIX + filepath);
    } else if (_.isObject(obj[key])) {
      outputObject[key] = prependRuntimeOutputPath(obj[key]);
    }
  });

  return outputObject;
};


module.exports = async function renderBundle(stats, entryPoint = process.env.ENTRY_POINT) {
  const context = {
    js: [],
    css: [],
    config: {
      assetHost: process.env.ASSET_HOST || '',
    },
  };

  let assets;

  if (stats) {
    assets = extractAssets(stats.toJson());
  } else {
    try {
      assets = await fs.readFile(path.join(outputPath(entryPoint), 'assets.json'), 'utf8')
        .then(assetObject => JSON.parse(assetObject));
    } catch (err) {
      throw new Error(`Unable to render client bundle. Invalid assets.json - ${err}`);
    }
  }

  if (process.env.PUBLIC_PATH_PREFIX) {
    assets = prependRuntimeOutputPath(assets);
  }


  function populateContext(entry) {
    context.css = assets[entry].css || [];
    context.js = assets[entry].js || [];
  }

  if (entryPoint) {
    if (!assets[entryPoint]) {
      throw new Error(`Invalid entry point: ${entryPoint}`);
    }

    populateContext(entryPoint);
  } else {
    // if the application has multiple entry points, only render assets for one
    const entryPoints = Object.keys(assets);
    const ep = entryPoints[0];

    if (entryPoints.length > 1) {
      console.warn(chalk.bold.yellow(`No entry point supplied; assuming ${ep}`)); // eslint-disable-line no-console
    }

    populateContext(ep);
  }

  let indexTemplateFilePath = resolve('index.template.html');
  const projectIndexTemplateFile = await fs.exists(indexTemplateFilePath);

  if (projectIndexTemplateFile) {
    console.warn(chalk.bold.yellow('Using custom index.template.html from project (prefer-core)')); // eslint-disable-line no-console
  } else {
    indexTemplateFilePath = path.resolve(__dirname, 'index.template.html');
    console.warn(chalk.green('Using index.template.html from core')); // eslint-disable-line no-console
  }

  return new Promise((done, reject) => {
    ejs.renderFile(indexTemplateFilePath, { ...context, entryPoint }, {}, (err, html) => {
      if (err) {
        reject(err);
      } else {
        fs.outputFile(`${resolve()}/index.hbs`, html).then(() => done(html)).catch(reject);
      }
    });
  });
};
