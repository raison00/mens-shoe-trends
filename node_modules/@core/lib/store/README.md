# store.js
> Fully isomorphic / universal data store for sharing state between the server and client.

## The problem
Modern JS browser applications often make XHR (AJAX) requests to retrieve data from a JSON service. Typically, this involves populating a client-side model with the data after a user interaction (e.g. navigating to a new page). However, the initial page load should also be rendered server-side for multiple reasons (i.e. SEO benefits, performance, etc.).

In order to fully render the page server-side, the node server needs to retrieve the data. It makes an HTTP/S request to an external service (i.e. xAPI), populates the server-side context, then renders. There is no inherent way to share that same data payload to populate the client-side model after the initial page is served, or to prevent the client-side view from re-rendering.

## The solution
This module provides a mechanism for storing and retrieving data through a common interface. It works both in node and in the browser. After all custom middleware is run, `@core/server` populates the SSR context with the data in the shared store. Additionally, the client-side entry point populates the client store with whatever initial state exists on page load.

## Usage
> store.js API documentation

#### store.get([propPath])

Returns a copy of whatever exists at `propPath`. Accepts a string representation to describe a nested path using array/dot notation. If `propPath` is omitted, a copy of the entire store is returned.

*examples:*
```js
store.get('product.productDetails');
```
```js
store.get(); // returns a copy of the entire store
```
> See [ObjectUtil.getChildProperty](https://code.devops.fds.com/polaris/component/common/blob/master/src/util/ObjectUtil.js#L58) for more information on valid propPath strings.

#### store.set(propPath, data)

Stores a copy of `data` at `propPath`. Accepts a string representation to describe a nested path using array/dot notation.

*example:*
```js
store.set('product.productDetails', { foo: { bar: 'baz' }});
```
> See [ObjectUtil.setChildProperty](https://code.devops.fds.com/polaris/component/common/blob/master/src/util/ObjectUtil.js#L101) for more information on valid propPath strings.

#### store.replaceState(state)

Replaces the contents of the store with a copy of every item in the `state` object. **Be careful:** this functionality is only intended to be called once in an entire application lifecycle (i.e. initial page load).

*example:*
```js
store.set('product.productDetails', { foo: { bar: 'baz' }});
console.log(store.get('product.productDetails')); // outputs "{ foo: { bar: 'baz' }}"

store.replaceState({
  product: {
    productDetails: { a: { b: 'c' }}
  }
});

console.log(store.get('product.productDetails')); // outputs "{ a: { b: 'c' }}"
```
> See how this is implemented in the client-side entry point bundled with core: [entry.js](https://code.devops.fds.com/polaris/core/build/blob/master/lib/entry.js)

## Example

For the sake of developer convenience, the entire server-->client state management is handled by the core. Simply use the [store.js API](#usage) with the intstances already set up by core:

- On the server-side, the `store` instance is attached to `req.locals`. This ensures the state is persistent across the request, and only across the request.
- On the client-side, the `store` instance is exported by this module. To use it, simply:

```js
import store from '@core/lib/store';
```

**NOTE:** It is important not to tree-shake methods off of `store`. Since the module exports an _instance_ of a class, tree-shaking `get`, `set` methods will change the instance context to the import scope (usually `window`). Since the methods internally use `this`, an error will be thrown.

```js
// DO NOT DO THIS
import { get, set } from '@core/lib/store';
get('foo'); // throws error

// OK
import store from '@core/lib/store';
store.get('foo');
```

A typical flow might look like this:

**server-side**
```js
/**
 * @file server/index.js
 */
const request = require('request-promise-native');
const Server = require('@core/server');
const filter = require('../shared/example-filter'); // example filter is a noop

const server = new Server();

// example express middleware that calls xAPI, populates SSR context, and copies the data into the shared store
server.app.get('/my-example-page', (req, res, next) => {
  request({ uri: `${process.env.SOME_XAPI_URL}/xapi/some-example-url`, json: true })
    .then((data) => {
      const filteredData = filter(data); // arbitrary data filter function

      req.locals.context.example = filteredData; // store the data in SSR context for rendering main.hbs server-side
      req.locals.store.set('example', filteredData); // copy the data into the "example" store so the client can use the shared state
      next();
    })
    .catch((err) => {
      console.error(err);
      res.sendStatus(500);
    });
});

// example express middleware that proxies a request to xAPI and responds with the JSON from the target server
server.app.get('/xapi/some-example-url', (req, res, next) => {
  request({ uri: `${process.env.SOME_XAPI_URL}/xapi/some-example-url`, json: true })
    .then((data) => {
      res.json(data);
    })
    .catch((err) => {
      console.error(err);
      res.sendStatus(500);
    });
});
```

**client-side**
```js
/**
 * @file src/models/example.js
 */
import store from '@core/lib/store';
import filter from '../../shared/example-filter';

const data = store.get('example'); // check for initial state populated by the server

export default Backbone.Model.extend({
  url: '/xapi/some-example-url',

  // populate the model data with any initial state that exists when the instance is created
  initialize() {
    if (data) {
      this.set(data);
    }
  }

  // the raw xapi response from any calls to fetch() should be filtered in the same way
  parse: (response) => filter(response),
});
```

```js
/**
 * @file src/views/example.js
 */
import _ from 'underscore';
import Marionette from 'backbone.marionette';
import ExampleModel from '../models/example';
import template from '../templates/example.hbs';

export default Marionette.ItemView.extend({
  el: '#example',
  template,
  model: new ExampleModel(),
  modelEvents: {
    change: 'render', // re-render each time the model is changed (i.e. after fetch)
  },
  initialize() {
    this.model = new ExampleModel();

    // Only fetch if initial state hasn't already populated model data
    if (_.isEmpty(this.model.attributes)) {
      // no initial state; view should fetch the data, which will trigger the "change" modelEvent
      this.model.fetch();
    }
  }
});
```

## Taking advantage of the json proxy to simplify your code
The server has a built-in [json proxy](https://code.devops.fds.com/polaris/core/server/tree/master#serverjsonproxyoptions), that automatically populates server-side context and shares state between the client and server using `store.js`. The above example server can be simplified as:

```js
/**
 * @file server/index.js
 */
const Server = require('@core/server');
const filter = require('../shared/example-filter'); // example filter is a noop

const server = new Server();

// example express middleware that calls xAPI, populates SSR context, and copies the data into the shared store
server.app.get('/my-example-page', server.jsonProxy({
  host: process.env.SOME_XAPI_URL,
  url: '/xapi/some-example-url',
  propPath: 'example',
  filter, // arbitrary data filter function
}));

// example express middleware that proxies a request to xAPI and responds with the JSON from the target server
server.app.get('/xapi/some-example-url', server.jsonProxy({
  host: process.env.XAPI_HOST,
  propPath: 'example',
  completeRequest: true,
}));
```

## How it works
Internally, the core server attaches a new `store` instance to `req.locals`, in a middleware that runs early:

```js
req.locals.__STORE__ = {}; // should never be used directly
req.locals.store = new Store(req.locals.__STORE__);
```
> from [@core/server - common.js](https://code.devops.fds.com/polaris/core/server/blob/master/lib/common.js)

This enables anyone to interact with the store throughout the lifecycle of the request using the [store.js API](#usage).

The core server then populates the SSR context with `__INITIAL_STATE__`, in a middleware that runs late:
```js
res.render(template, {
  ...req.locals.context,
  __INITIAL_STATE__: JSON.stringify(req.locals.store.get()),
});
```
> from [@core/server - ssr.js](https://code.devops.fds.com/polaris/core/server/blob/master/lib/ssr.js)

This context is used by `index.template.html` to populate `window.__INITIAL_STATE__`:

```html
{{#if __INITIAL_STATE__}}
<script type="text/javascript">
  window.__INITIAL_STATE__ = {{{__INITIAL_STATE__}}};
</script>
{{/if}}
```
> from [@core/lib/render-bundle - index.template.html](https://code.devops.fds.com/polaris/core/lib/blob/master/render-bundle/index.template.html)

Finally, the client-side entry point populates the client store with the initial state data:

```js
if (window.__INITIAL_STATE__) {
  store.replaceState(window.__INITIAL_STATE__);
}
```
> from [@core/build - entry.js](https://code.devops.fds.com/polaris/core/build/blob/master/lib/entry.js)

This enables the client side to populate it's models/collections with data that exists in the initial state by using the [store.js API](#usage).
