import test from 'ava';
import Store from '../Store';

test('Store should export a newable function that creates an instance of Store', (t) => {
  t.is(typeof Store, 'function');
  const store = new Store();
  t.true(store instanceof Store);
});

test('Store instances should export a get() method that allows for deep object value retrieval', (t) => {
  const data = { foo: { bar: { baz: 'qux' } } };
  const store = new Store(data);

  t.deepEqual(store.get('foo.bar'), data.foo.bar);
  t.not(store.get('foo.bar'), data.foo.bar); // ensure a clone is returned, not a reference
});

test('Store instances should export a set() method that allows for deep object value setting', (t) => {
  const store = new Store();
  const data = { baz: 'qux' };
  store.set('foo.bar', data);

  t.deepEqual(store.get('foo.bar'), data); // can assume get() works since it is tested separately
  t.not(store.get('foo.bar'), data); // ensure a clone is stored, not a reference
});

test('Store instances should retrieve the full store if get() is called without propPath', (t) => {
  const data = { foo: { bar: 'baz' }, qux: { waldo: 'thud' } };
  const store = new Store(data);

  t.deepEqual(store.get(), data);
  t.not(store.get(), data); // ensure a clone is returned, not a reference
});

test('Store instances should throw an error if set() is called without propPath', (t) => {
  const store = new Store();
  t.throws(store.set, 'store.set() must be called with a "propPath"');
});

test('Store instances should export a replaceState() method that overrides the store\'s state', (t) => {
  const store = new Store({ foo: 'bar' }); // initial store data will get replaced
  const data = { foo: { bar: 'baz' } };
  store.replaceState(data);

  t.deepEqual(store.get(), data);
  t.not(store.get(), data); // ensure a clone is returned, not a reference
});
