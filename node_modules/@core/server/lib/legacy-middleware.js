/**
 * Allow a project to merge specific legacy middlewares from child projects.
 *
 * In the future, all middleware should either be attached to the server.app instance,
 * or implicitly (dynamically) inherited from child projects - recursively.
 *
 * @TODO drop legacy middleware support
 */

const _ = require('lodash');
const path = require('path');
const { pkg, resolve } = require('@core/lib/project')();
const errorHandler = require('./error-handler');

/**
 * Attempts to load middleware relative to the project + "root". Assumes middleware is located
 * at server/legacy-middleware.js in all cases.
 *
 * Returns a partial function that will call middleware(req, options). Done this way because
 * options don't change at request-time. Also makes it easy to chain promises.
 *
 * middleware(req, options) is expected to return a promise, but no validation is done around this.
 */
const loadMiddleware = (root = '', options = {}) => {
  let middleware;

  try {
    // eslint-disable-next-line import/no-dynamic-require
    middleware = require(resolve(path.join(root, 'server/legacy-middleware')));
  } catch (err) {
    errorHandler(err, true);
  }

  return req => middleware(req, options);
};

/**
 * Two formats for options.legacyMiddleware are allowed:
 *
 *   1) Boolean: if legacyMiddleware = true, the project's legacy-middleware will be used:
 *         true --> require('./legacy-middleware');
 *
 *   2) Array: if legacyMiddleware is an array, the below logic will be used:
 *         The format of options.legacyMiddleware is similar to that of karma.conf's files[] array:
 *             [
 *                { '@feature/some-thing': { foo: 'bar' } },
 *                '@feature/my-thing',
 *                '@feature/some-other-thing',
 *             ]
 *
 *         The order of items in the array determines the order that they will be run.
 *
 *         If the item in the array is an object, then it is assumed to have a single key/value pair.
 *         The key is used to identify the project, and the value should be an object that is passed
 *         as options to the legacy middleware.
 *
 *         If the item in the array is a string, then the legacy middleware will be called without options.
 *
 *         For the project identifier, the string should always start with "@"
 *
 *             - If the string does not start with "@", an error will be thrown.
 *             - If the string matches the project name, it will resolve the legacy-middleware from the project. For example:
 *                  '@feature/my-thing' --> require('./legacy-middleware');
 *             - Else it will resolve the legacy-middleware file within the project. For example:
 *                  '@feature/something' --> require('../node_modules/@feature/something/server/legacy-middleware');
 */
const format = (legacyMiddleware) => {
  const formatted = [];

  if (legacyMiddleware === true) {
    formatted.push(loadMiddleware());
  } else if (!_.isArray(legacyMiddleware)) {
    errorHandler(new Error('Invalid server options: legacyMiddleware must be a boolean or array'), true);
  } else {
    legacyMiddleware.forEach((middleware, idx) => {
      let project;
      let options;

      if (_.isString(middleware)) {
        project = middleware;
      } else if (_.isPlainObject(middleware)) {
        const keys = Object.keys(middleware);
        if (keys.length !== 1) {
          errorHandler(new Error(`Invalid server options: legacyMiddleware[${idx}] must be a string or object with one item`), true);
        }
        [project] = keys;
        options = middleware[project];

        if (!_.isPlainObject(options)) {
          errorHandler(new Error(`Invalid server options: legacyMiddleware[${idx}]['${project}'] must be an object`), true);
        }
      } else {
        errorHandler(new Error(`Invalid server options: legacyMiddleware[${idx}] must be a string or object with one item`), true);
      }

      if (project.indexOf('@') !== 0) {
        errorHandler(new Error(`Invalid server options: legacyMiddleware[${idx}] - '${project}' must begin with "@"`), true);
      }

      // it should resolve the legacy-middleware from the project if the project string matches the package name
      const root = (project === pkg.name) ? '' : `node_modules/${project}`;
      formatted.push(loadMiddleware(root, options));
    });
  }

  return formatted;
};

module.exports = function legacyMiddleware() {
  const { app } = this;
  const middleware = format(this.options.legacyMiddleware);
  const routes = this.options.legacyMiddlewareRoutes || ['/', '/shop/*'];

  if (!_.isArray(routes)) {
    throw new Error('Invalid server option: legacyMiddlewareRoutes must be an array');
  }

  app.get(routes, (req, res, next) => {
    /**
     * Custom middleware should not cause a fatal error. capture errors and continue.
     *
     * The promise catch will capture errors thrown by the context request.
     * The try/catch will capture errors thrown in the custom middleware itself.
     */
    try {
      const middlewarePromises = [];
      middleware.forEach((mware) => {
        // options have been partialled in ( middleware(req, options) ) - @see loadMiddleware()
        middlewarePromises.push(mware(req).then((context) => {
          // merge results on top of existing context
          req.locals.context = { ...req.locals.context, ...context };
        }));
      });

      // parallelize the async middleware operations
      Promise.all(middlewarePromises)
        .then(() => next())
        .catch((err) => {
          errorHandler(err);
          res.sendStatus(500);
        });
    } catch (err) {
      errorHandler(err);
      res.sendStatus(500);
    }
  });
};
