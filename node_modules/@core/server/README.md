# Server
> Common node web server interface used for development and production applications of all types (page/feature/component).

## Features
- Sets up an [express app](https://expressjs.com/) and exposes it directly to the consumer
- Sets up common express [middleware](http://expressjs.com/en/guide/using-middleware.html)
- Controls error handling flow for core components
- Exposes a [proxy](#serverjsonproxyoptions) for handling requests to external JSON APIs (i.e. xAPI):
    - populates context for rendering templates server-side with the results of the external API
    - enables a shared client/server datastore to populate client state without making multiple calls
    - enables data mocking in development mode
- Exposes a [start](#serverstart) method that does the following:
    - attaches fallback middleware to capture specific known error cases (i.e. missing routes)
    - attaches [server-side rendering (SSR)](#server-side-rendering-ssr) middleware
    - launches the express server with common configuration

Additionally, the behavior changes depending on the value of `NODE_ENV`:

##### development
- used for local development.
- can be launched using `m server`, which uses the `--development` option by default.
- enables [@core/dev-server](https://code.devops.fds.com/polaris/core/dev-server), which includes [HMR](https://webpack.js.org/concepts/hot-module-replacement/) without any setup.
- the application will be built in memory. Don't expect to see a `/dist` directory.

##### production
- used to simulate production.
- can be launched using `m server --production`.
- it is assumed that the application has already been built via `m build`.
- in this situation, [HMR](https://webpack.js.org/concepts/hot-module-replacement/) will not be enabled.

## Installation
```
# for production usage (i.e. pages)
npm i @core/server
npm i @core/dev-server --save-dev

# for dev usage (i.e. components)
npm i @core/server --save-dev
npm i @core/dev-server --save-dev
```

## Usage
> Server API documentation

### Server

The class exported by [@core/server](https://code.devops.fds.com/polaris/core/server).

#### new Server([options])

Creates an instance of [Server](#server-1), with the supplied `options`.

Possible options:

- `legacyMiddleware` - enable the usage of [legacy middleware](#legacy-middleware)
- `legacyMiddlewareRoutes` - specify an array of routes to run legacy middleware against. Defaults to `['/', '/shop/*']`.

Returns a new [server](#server-2) instance.

### server

A single instance of [Server](#server-1).

#### server.app

The [express](https://expressjs.com/) instance. Use this to attach custom middleware before starting the server:

```js
server.app.use((req, res, next) => {
  next();
});
```
> If the above syntax is unfamiliar, learn more about [express middleware](http://expressjs.com/en/guide/writing-middleware.html).

#### server.jsonProxy(options)

Make a request to an external API (i.e. xAPI). Can be used as a simple JSON proxy, or to store API results in context for server-side rendering.

If shared store is enabled, then the proxy will additionally cache the results to be used by the client-side store.

*examples:*

```js
// Example of using server.jsonProxy to make a request to an external API (i.e. xAPI), then respond with the JSON result.
app.get('/xapi/custom-things-endpoint', server.jsonProxy({ host: process.env.XAPI_HOST, propPath: 'some.things.path', completeRequest: true }));

// Example of using server.jsonProxy to make a request to an external API (i.e. xAPI), then cache the results for SSR and populating the client-side store.
app.get('/things', server.jsonProxy({ host: process.env.XAPI_HOST, url: '/xapi/custom-things-endpoint', propPath: 'some.things.path' }));
```

If mock is enabled at the time the server is newed (e.g. if `server.mock` = `true` or the environment variable `MOCK_ENABLED` = `yes`),
then `server/mock.js` will be used to resolve mock data for calls made via `server.jsonProxy` (for `NODE_ENV` = `development`).

Possible options:

- `host` - the proxy host (required)
- `url` - the proxy url. Defaults to `req.url`
- `headers` - headers to send to the target server
- `propPath` - the object path to store the results (in `req.locals.context` and optionally the shared store). Required if `completeRequest` is `false`.
- `completeRequest` - If `true`, the server request will complete, responding with the JSON data. If `false`, the results are stored in `req.locals.context[store]` and `next()` is called, continuing to the next middleware. Defaults to `false`.
- `sharedState` - If `true`, the JSON data will be stored in the [common data store](), and will populate the client-side store with the same data on page load. Note that this honors the `filter` option. Defaults to `true`.
- `filter` - optionally filter the results before storing them. Will filter results before storing in both SSR context (`req.locals.context`) and shared state store.
- `renderFilter` - optionally filter the results before storing them in SSR context (`req.locals.context`). Takes precedence over the `filter` option.
- `sharedStateFilter` - optionally filter the results before copying them into the shared client/server state store. Takes precedence over the `filter` option.

Returns an [express middleware](http://expressjs.com/en/guide/writing-middleware.html).

#### server.start()

Enables server-side rendering (SSR) and starts the server.
> Should be run last, after attaching all other custom [express middleware](http://expressjs.com/en/guide/writing-middleware.html).

## Server-side rendering (SSR)

This server supports full SSR via [Handlebars](http://handlebarsjs.com/). There are four keys to understanding how it works:

### src/templates/main.hbs

This is the main page wrapper used by the server-side renderer (SSR). When a request comes to an instance of `@core/server`, the following actions pertaining to SSR will occur:

  1) When creating an instance of [Server](#new-serveroptions), common middleware will populate `req.locals.context` with data that pertains to everyone (e.g. `analyticsURL`).
    > read more about [express middleware](http://expressjs.com/en/guide/using-middleware.html) if you are unfamiliar with the concept of `req`.

  2) At request-time, the core server will run any [custom middleware](http://expressjs.com/en/guide/using-middleware.html) attached to [server.app](#serverapp). This gives your project a change to append data to `req.locals.context`.
    > *DO NOT* overwrite `req.locals.context` completely. This will kill the context set by the common middleware attached by `@core/server`. It will result in strange behavior, and the page may not render correctly. Use [_.defaults](http://underscorejs.org/#defaults) or [_.extend](http://underscorejs.org/#extend) instead.

  3) After all common and custom middleware has run, the server will compile `main.hbs` with [Handlebars](http://handlebarsjs.com/). The context used to compile the template will be whatever data exists in `req.locals.context`.

### src/templates/partials/
> If you are not comfortable with the concept of [Handlebars partials](http://handlebarsjs.com/partials.html), please familiarize yourself with it before continuing.

This is the directory root for resolving all partials. For example, if a partial exists at `src/templates/partials/my-component.hbs`, the partial can be used in a template by using `{{> my-component}}`. The partial will be compiled with the template at compile-time. Therefore, if it is referenced via `main.hbs`, it will be rendered server-side.

### src/helpers/
> If you are not comfortable with the concept of Handlebars [helpers](http://handlebarsjs.com/expressions.html) or [block helpers](http://handlebarsjs.com/block_helpers.html), please familiarize yourself with it before continuing.

This is the directory root for resolving all helpers. For example, if a helper exists at `src/helpers/my-helper.js`, the helper can be used in a template by using `{{my-helper}}`. The partial will *not* be compiled with the template at compile-time.

Instead, helpers are run-time javascript. Since `node.js` does not natively support `ES6`, all handlebars helpers must be written without the use of `ES6`. Else, the helpers will fail to run on the server-side during SSR.

### Composing templates from dependencies

The reason the `templates/` path must be fixed is so that the core can compose partials and helpers across multiple projects. For example, let's assume your project has the following dependencies in `package.json`:

```js
{
  "name": "@component/component-1",
  "dependencies": {
    "@component/component-2",
    "@component/component-3"
  }
}
```

In this situation, the core build and server processes will have knowledge of the following paths:

*for resolving partials:*
  - component-1/src/templates/partials
  - component-2/src/templates/partials
  - component-3/src/templates/partials

*for resolving helpers:*
  - component-1/src/helpers/
  - component-2/src/helpers/
  - component-3/src/helpers/

## Legacy middleware

This server included backwards compatible support for legacy middleware files (i.e. `lib/middleware.js`).

To enable this feature, move the file to `server/legacy-middleware.js` and instantiate the [Server](#new-serveroptions) with the `legacyMiddleware` option:

```js
const server = new Server({ legacyMiddleware: true });
```

The context data resolved by legacy middleware will be available in `req.locals.context`:

```js
server.app.use((req, res, next) => {
  console.log(req.locals.context); // context object populated by @core/server and legacy middleware
  next();
});
```
> If the above syntax is unfamiliar, learn more about [express middleware](http://expressjs.com/en/guide/writing-middleware.html).

To merge together the context data resolved from legacy middleware in child dependencies, pass `legacyMiddleware` as an array:

```js
const server = new Server({
  legacyMiddleware: ['@feature/header', '@feature/footer', '@feature/mine']
});
```
> legacy middleware will be run in the order they are provided, and the context data resolved from later middleware takes precedence.

For legacy middleware that takes custom options, convert the array item from a string to an object:

```js
const server = new Server({
  legacyMiddleware: [
    { '@feature/header': { foo: 'bar' } },
    '@feature/footer',
    '@feature/mine'
  ],
});
```

The legacy middleware for the feature will then have access to the options:

```js
middleware(req, { foo: 'bar' });
```

You can also specify `legacyMiddlewareRoutes`, to restrict or expand which routes will execute the legacy middleware and populate context in `req.locals.context`.
Defaults to `['/', '/shop/*']`. An error will be thrown if `legacyMiddlewareRoutes` is not an array.

## Example
```js
const Server = require('@core/server');

const server = new Server({
  // join legacy middleware from this project and other projects
  legacyMiddleware: ['@feature/header', '@feature/footer', '@feature/mine'],
});

const { app } = server; // server.app is the express instance http://expressjs.com/

// add custom express middleware http://expressjs.com/en/guide/writing-middleware.html
app.use((req, res, next) => {
  console.log(req.locals.context); // context object populated by @core/server and legacy middleware
  next();
});

server.start(); // should be run last
```
