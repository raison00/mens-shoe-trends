/**
 * Application server. Works for development and production.
 *
 * - Attaches a new express app to this.app
 *      - @see https://expressjs.com/
 * - Sets up common express middleware
 *      - @see ./common.js
 * - Controls error handling flow for core components
 *      - @see ./error-handler.js
 * - Exposes a start() method that does the following:
 *      - attaches fallback middleware to capture specific known error cases (i.e. missing routes)
 *      - attaches server-side rendering (SSR) handling, to enforce that it is attached
 *        after all other custom middleware - @see ./ssr.js
 *      - launches the express server with common configuration
 */
const _ = require('lodash');
const express = require('express');
const path = require('path');
const throng = require('throng');
const renderBundle = require('@core/lib/render-bundle');
const { helpers, partialDirs } = require('@core/lib/handlebars')();
const resolve = require('@core/lib/project/resolve');
const common = require('./lib/common');
const errorHandler = require('./lib/error-handler');
const jsonProxy = require('./lib/json-proxy');
const ssr = require('./lib/ssr');

const isDev = process.env.NODE_ENV === 'development';
const pkg = require(resolve('package.json')); // eslint-disable-line import/no-dynamic-require

module.exports = class Server {
  constructor(options = {}) {
    const handlebars = {
      helpers: helpers(),
      // careful - partialsDir (express-handlebars) vs partialDirs (handlebars-loader)
      partialsDir: partialDirs,
    };

    this.mock = options.mock || process.env.MOCK_ENABLED === 'yes';
    this.handlebars = () => _.clone(handlebars, true); // clone to prevent caller from mutating
    this.options = options;
    this.app = express();
    this.jsonProxy = jsonProxy.bind(this);
    this.port = process.env.PORT || 8081;
    common.apply(this);

    if (this.mock) {
      try {
        this.mockRoutes = require(resolve('server/mock.js')); // eslint-disable-line import/no-dynamic-require
      } catch (err) {
        throw new Error('Invalid server/mock.js file');
      }
    }

    const start = (stats) => {
      // attach fallback middleware to capture specific known error cases (i.e. missing routes)
      this.app.get('*', (req, res, next) => {
        const fileExtension = path.extname(req.url);

        if (fileExtension) {
          // eslint-disable-next-line no-console
          console.error(new Error(`Detected file with extension (${fileExtension}). File not found: ${req.url}`));
          res.sendStatus(404);
        } else {
          next();
        }
      });

      if (this.notFound) {
        this.app.use(this.notFound);
      }

      // attach server-side rendering middleware late, to enforce that it is attached last.
      try {
        ssr.call(this, { ...handlebars, ...{ stats } });
      } catch (err) {
        errorHandler(err, true); // fatal - there is an error configuring the handlebars engine
      }

      const listen = () => {
        if (process.env.NODE_ENV !== 'test') {
          this.app.listen(this.port, () => {
            console.log(`server listening on port: ${this.port}`); // eslint-disable-line no-console
          });
        }
      };

      // optimize application concurrency by clustering.
      // assumes throng has been incorporated into the project if it exists in pacakge.json. This is for backwards-compatibility
      // @TODO remove the dependencies check for throng once its removed from each individual project
      if (process.env.NODE_ENV === 'production' && !_.has(pkg, 'dependencies.throng')) {
        throng(listen, { workers: process.env.WEB_CONCURRENCY || 1, lifetime: Infinity });
      } else {
        listen();
      }
    };

    // exposed method nested in constructor to prevent unnecessary binding of private method listen()
    this.start = async () => {
      if (isDev) {
        // must be in isDev block, else HMR dependencies won't exist
        await require('@core/dev-server').apply(this).then(start).catch((err) => {
          errorHandler(err, true); // fatal - rejection in attempting to initialize HMR
        });
      } else {
        try {
          await renderBundle.call(this); // for production, render bundle once
        } catch (err) {
          errorHandler(err, true); // fatal - the index file can't get rendered
        }

        start();
      }
    };
  }
};
